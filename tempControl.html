<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DDPGÂº∫ÂåñÂ≠¶‰π†ÊéßÊ∏©Á≥ªÁªü</title>
    <!-- 2025-06-12 Êõ¥Êñ∞: ËÆ≠ÁªÉËΩ®Ëøπ‰ºòÂåñÁâàÊú¨ -->
    <!-- ‰ΩøÁî®Â§ö‰∏™CDNÂ§áÈÄâÊñπÊ°à -->
    <script>
        // Âä®ÊÄÅÂä†ËΩΩTensorFlow.js
        function loadScript(src, fallbacks = []) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => {
                    if (fallbacks.length > 0) {
                        loadScript(fallbacks.shift(), fallbacks).then(resolve).catch(reject);
                    } else {
                        reject(new Error(`Failed to load script: ${src}`));
                    }
                };
                document.head.appendChild(script);
            });
        }

        // Âä†ËΩΩÂøÖË¶ÅÁöÑÂ∫ì
        Promise.all([
            loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js', [
                'https://unpkg.com/@tensorflow/tfjs@latest/dist/tf.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js'
            ]),
            loadScript('https://cdn.jsdelivr.net/npm/chart.js', [
                'https://unpkg.com/chart.js',
                'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js'
            ])
        ]).then(() => {
            // Âº∫Âà∂ÂàáÊç¢ÂêéÁ´ØÂπ∂Á≠âÂà∞ ready ÂêéÂÜçÂàùÂßãÂåñ
            tf.setBackend('cpu').then(() => {
                tf.ready().then(() => {
                    console.log('Â∑≤ÂàáÊç¢Âà∞ CPU backend');
                    window.librariesLoaded = true;
                    if (window.initializeApp) window.initializeApp();
                });
            });
        }).catch(error => {
            console.error('Â∫ìÂä†ËΩΩÂ§±Ë¥•:', error);
            document.body.innerHTML = `
                <div style="padding: 20px; text-align: center; color: red;">
                    <h2>‚ö†Ô∏è ÁΩëÁªúÂ∫ìÂä†ËΩΩÂ§±Ë¥•</h2>
                    <p>ËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•Êàñ‰ΩøÁî®Á¶ªÁ∫øÁâàÊú¨</p>
                    <p>ÈîôËØØ‰ø°ÊÅØ: ${error.message}</p>
                    <button onclick="location.reload()">ÈáçÊñ∞Âä†ËΩΩ</button>
                </div>
            `;
        });
    </script>
    <style>
        /* ‰øùÁïôÂéüÊúâCSSÊ†∑Âºè */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 10px;
            color: white;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 14px;
        }

        .control-group input,
        .control-group select {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .btn:hover:before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #218838);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #17a2b8, #138496);
            color: white;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: 600;
            background: linear-gradient(45deg, #e9ecef, #f8f9fa);
            border-left: 5px solid #007bff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .chart-container h3 {
            margin: 0 0 15px 0;
            color: #495057;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .log-container {
            height: 250px;
            overflow-y: auto;
            border: 2px solid #dee2e6;
            padding: 15px;
            background: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border-radius: 8px;
            line-height: 1.4;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            font-size: 18px;
            color: #6c757d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #stopTest {
            display: none;
        }

        .metric-card {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 10px 0;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 12px;
            opacity: 0.9;
        }

        /* Êñ∞Â¢û: ËøõÂ∫¶ÊåáÁ§∫Âô®Ê†∑Âºè */
        .progress-container {
            margin: 15px 0;
            background-color: #f0f0f0;
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            transition: width 0.5s;
            position: relative;
        }

        /* Êñ∞Â¢û: ËÆ≠ÁªÉÊåáÊ†áÂç°Áâá */
        .training-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .metric-mini-card {
            background: linear-gradient(45deg, #4b6cb7, #182848);
            padding: 10px;
            border-radius: 8px;
            color: white;
            text-align: center;
        }

        .metric-mini-value {
            font-size: 18px;
            font-weight: bold;
        }

        .metric-mini-label {
            font-size: 11px;
            opacity: 0.9;
        }
    </style>
</head>

<body>
    <!-- ‰øùÁïôÂéüÊúâHTMLÁªìÊûÑ -->
    <div class="container">
        <div class="header">
            <h1>ü§ñ DDPGÂº∫ÂåñÂ≠¶‰π†Êô∫ËÉΩÊéßÊ∏©Á≥ªÁªü</h1>
            <p>Âü∫‰∫éÊ∑±Â∫¶Á°ÆÂÆöÊÄßÁ≠ñÁï•Ê¢ØÂ∫¶ÁöÑËøûÁª≠ÊéßÂà∂</p>
        </div>

        <div id="loadingIndicator" class="loading">
            <div class="spinner"></div>
            Ê≠£Âú®Âä†ËΩΩÁ≥ªÁªüÁªÑ‰ª∂...
        </div>

        <div id="mainContent" style="display: none;">
            <!-- ÊéßÂà∂ÂèÇÊï∞ -->
            <div class="controls">
                <div class="control-group">
                    <label for="targetWaterTemp">üéØ ÊµãËØïÈò∂ÊÆµÁõÆÊ†áÊ∞¥Ê∏© (¬∞C)</label>
                    <input type="number" id="targetWaterTemp" value="45" min="20" max="100" step="0.1">
                </div>
                <div class="control-group">
                    <label for="initWaterTemp">üå°Ô∏è ÂàùÂßãÊ∞¥Ê∏© (¬∞C)</label>
                    <input type="number" id="initWaterTemp" value="25" min="10" max="50" step="0.1">
                </div>
                <div class="control-group">
                    <label for="roomTempInput">üè† ÁéØÂ¢ÉÊ∏©Â∫¶ (¬∞C)</label>
                    <input type="number" id="roomTempInput" value="22" min="10" max="40" step="0.1">
                </div>
                <div class="control-group">
                    <label for="maxPowerInput">‚ö° ÊúÄÂ§ßÂäüÁéá (W)</label>
                    <input type="number" id="maxPowerInput" value="3000" min="500" max="5000" step="100">
                </div>
                <div class="control-group">
                    <label for="hAInput">üîÑ ‰º†ÁÉ≠Á≥ªÊï∞</label>
                    <input type="number" id="hAInput" value="60" min="20" max="100" step="1">
                </div>
                <div class="control-group">
                    <label for="waterMassInput">üíß Ê∞¥Ë¥®Èáè (kg)</label>
                    <input type="number" id="waterMassInput" value="1.0" min="0.1" max="5.0" step="0.1">
                </div>
                <div class="control-group">
                    <label for="epochs">üîÑ ËÆ≠ÁªÉËΩÆÊï∞</label>
                    <input type="number" id="epochs" value="200" min="50" max="1000" step="10">
                </div>
                <div class="control-group">
                    <label for="modelComplexity">üß† Ê®°ÂûãÂ§çÊùÇÂ∫¶</label>
                    <select id="modelComplexity">
                        <option value="1">ÊûÅÁÆÄ (1Â±Ç)</option>
                        <option value="2">ÂæàÁÆÄ (2Â±Ç)</option>
                        <option value="3" selected>ÁÆÄÂçï (3Â±Ç)</option>
                        <option value="4">‰∏≠Á≠â (4Â±Ç)</option>
                        <option value="5">Â§çÊùÇ (5Â±Ç)</option>
                        <option value="6">ÂæàÂ§çÊùÇ (6Â±Ç)</option>
                        <option value="7">Ë∂ÖÂ§çÊùÇ (7Â±Ç)</option>
                        <option value="8">ÊûÅËá¥ (8Â±Ç)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="algorithmSelect">üßÆ ÁÆóÊ≥ï</label>
                    <select id="algorithmSelect">
                        <option value="ddpg" selected>DDPG</option>
                        <option value="td3">TD3</option>
                        <option value="sac">SAC</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="simSpeed">‚è±Ô∏è ‰ªøÁúüÈÄüÂ∫¶ (Áßí)</label>
                    <input type="number" id="simSpeed" value="0.01" min="0" max="2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="deltaT">üîß ‰ªøÁúüÊ≠•Èïø Œît (s)</label>
                    <input type="number" id="deltaT" value="1" min="1" max="5" step="0.1">
                </div>
            </div>

            <!-- ÊéßÂà∂ÊåâÈíÆ -->
            <div class="buttons">
                <button id="startTraining" class="btn btn-primary">üöÄ ÂºÄÂßãËÆ≠ÁªÉ</button>
                <button id="stopTraining" class="btn btn-danger">‚èπÔ∏è ÂÅúÊ≠¢ËÆ≠ÁªÉ</button>
                <button id="testModel" class="btn btn-success">üß™ ÊµãËØïÊéßÊ∏©</button>
                <button id="stopTest" class="btn btn-danger">‚èπÔ∏è ÂÅúÊ≠¢ÊµãËØï</button>
                <button id="saveModel" class="btn btn-info">üíæ ‰øùÂ≠òÊ®°Âûã</button>
                <button id="loadModel" class="btn btn-info">üìÅ Âä†ËΩΩÊ®°Âûã</button>
            </div>

            <!-- Áä∂ÊÄÅÊòæÁ§∫ -->
            <div id="status" class="status">üü¢ Á≥ªÁªüÂ∞±Áª™ÔºåÂèØ‰ª•ÂºÄÂßãËÆ≠ÁªÉ</div>

            <!-- ËÆ≠ÁªÉËøõÂ∫¶Êù° (Êñ∞Â¢û) -->
            <div id="trainingProgress" style="display: none;">
                <p><strong>ËÆ≠ÁªÉËøõÂ∫¶:</strong> <span id="progressText">0%</span></p>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>

                <!-- ËÆ≠ÁªÉÊåáÊ†á (Êñ∞Â¢û) -->
                <div class="training-metrics" id="trainingMetricsPanel">
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="currentEpisode">--</div>
                        <div class="metric-mini-label">ÂΩìÂâçËΩÆÊ¨°</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="avgReward">--</div>
                        <div class="metric-mini-label">Âπ≥ÂùáÂ•ñÂä±</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="currentNoise">--</div>
                        <div class="metric-mini-label">Êé¢Á¥¢Âô™Â£∞</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="avgError">--</div>
                        <div class="metric-mini-label">Âπ≥ÂùáËØØÂ∑Æ(¬∞C)</div>
                    </div>
                </div>
            </div>

            <!-- ÂÆûÊó∂ÊåáÊ†á -->
            <div id="metricsPanel" style="display: none;">
                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                    <div class="metric-card">
                        <div class="metric-value" id="currentTemp">--</div>
                        <div class="metric-label">ÂΩìÂâçÊ∏©Â∫¶ (¬∞C)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentError">--</div>
                        <div class="metric-label">Ê∏©Â∫¶ËØØÂ∑Æ (¬∞C)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentPower">--</div>
                        <div class="metric-label">ÂΩìÂâçÂäüÁéá (W)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentReward">--</div>
                        <div class="metric-label">ÂΩìÂâçÂ•ñÂä±</div>
                    </div>
                </div>
            </div>

            <!-- ÂõæË°®ÊòæÁ§∫ -->
            <div class="charts">
                <div class="chart-container">
                    <h3>üìà ËÆ≠ÁªÉÂ•ñÂä±Êõ≤Á∫ø</h3>
                    <canvas id="lossChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <h3>üìâ Actor/CriticÊçüÂ§±Êõ≤Á∫ø</h3>
                    <canvas id="tdLossChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <h3>üî• ËÆ≠ÁªÉ‰∏≠Ê∞¥Ê∏©ËΩ®Ëøπ</h3>
                    <canvas id="trainCurveChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container full-width">
                    <h3>üå°Ô∏è ÊéßÊ∏©ËøáÁ®ãÊõ≤Á∫ø</h3>
                    <canvas id="testCurveChart" width="800" height="300"></canvas>
                </div>
                <!-- Êñ∞Â¢ûÂõæË°®: Ê∏©Â∫¶ËØØÂ∑ÆÊõ≤Á∫ø -->
                <div class="chart-container full-width">
                    <h3>üìä ËÆ≠ÁªÉËøáÁ®ãÊ∏©Â∫¶ËØØÂ∑ÆÂèòÂåñ</h3>
                    <canvas id="errorChart" width="800" height="300"></canvas>
                </div>
            </div>

            <!-- Êó•ÂøóÊòæÁ§∫ -->
            <div class="chart-container">
                <h3>üìã Á≥ªÁªüÊó•Âøó</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        // Á≠âÂæÖÂ∫ìÂä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñÂ∫îÁî®
        window.initializeApp = function () {
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';

            // Ê£ÄÊü•TensorFlow.jsÊòØÂê¶ÂèØÁî®
            if (typeof tf === 'undefined') {
                document.getElementById('status').innerHTML = '‚ùå TensorFlow.js Âä†ËΩΩÂ§±Ë¥•';
                return;
            }
            // Ê£ÄÊü• TensorFlow.js backend ÊòØÂê¶ÂèØÁî®
            if (!tf || !tf.engine().backend) {
                document.getElementById('status').innerHTML = '‚ùå TensorFlow.js backend Êú™Â∞±Áª™ÔºåËØ∑Âà∑Êñ∞ÈáçËØï';
                return;
            }

            // Ê£ÄÊü•Chart.jsÊòØÂê¶ÂèØÁî®
            if (typeof Chart === 'undefined') {
                document.getElementById('status').innerHTML = '‚ùå Chart.js Âä†ËΩΩÂ§±Ë¥•';
                return;
            }

            // ÂàùÂßãÂåñÊéßÂà∂Âô®
            window.controller = new MLController();
            console.log('üöÄ DDPGÊô∫ËÉΩÊéßÊ∏©Á≥ªÁªüÂ∑≤ÂêØÂä®');
        };

        // Â¶ÇÊûúÂ∫ìÂ∑≤ÁªèÂä†ËΩΩÂÆåÊàê
        if (window.librariesLoaded) {
            window.initializeApp();
        }

        // =========== ‰ºòÂÖàÁªèÈ™åÂõûÊîæÁºìÂÜ≤Âå∫ ===============
        class PrioritizedReplayBuffer {
            constructor(capacity, alpha = 0.6) {
                this.capacity = capacity;
                this.buffer = [];
                this.priorities = [];
                this.alpha = alpha;
                this.beta = 0.4;
                this.betaIncrement = 0.001;
                this.maxBeta = 1.0;
                this.epsilon = 1e-6;
            }

            add(experience, tdError = 1.0) {
                const priority = Math.pow(Math.abs(tdError) + this.epsilon, this.alpha);

                if (this.buffer.length < this.capacity) {
                    this.buffer.push(experience);
                    this.priorities.push(priority);
                } else {
                    const idx = Math.floor(Math.random() * this.capacity);
                    this.buffer[idx] = experience;
                    this.priorities[idx] = priority;
                }
            }

            sample(batchSize) {
                const indices = [];
                const experiences = [];
                const weights = [];

                if (this.buffer.length === 0) {
                    return { indices: [], experiences: [], weights: [] };
                }

                const totalPriority = this.priorities.reduce((sum, p) => sum + p, 0);

                // ‰øùÊä§: Á°Æ‰øùÊúâË∂≥Â§üÊï∞ÊçÆÂèØ‰ª•ÈááÊ†∑
                const actualBatchSize = Math.min(batchSize, this.buffer.length);

                for (let i = 0; i < actualBatchSize; i++) {
                    const rand = Math.random() * totalPriority;
                    let cumSum = 0;
                    let idx = 0;

                    for (let j = 0; j < this.priorities.length; j++) {
                        cumSum += this.priorities[j];
                        if (cumSum >= rand) {
                            idx = j;
                            break;
                        }
                    }

                    indices.push(idx);
                    experiences.push(this.buffer[idx]);

                    const prob = this.priorities[idx] / totalPriority;
                    const weight = Math.pow(prob * this.buffer.length, -this.beta);
                    weights.push(weight);
                }

                const maxWeight = Math.max(...weights, 0.00001); // Èò≤Ê≠¢Èô§Èõ∂ÈîôËØØ
                const normalizedWeights = weights.map(w => w / maxWeight);

                this.beta = Math.min(this.maxBeta, this.beta + this.betaIncrement);

                return { indices, experiences, weights: normalizedWeights };
            }

            updatePriorities(indices, tdErrors) {
                for (let i = 0; i < indices.length; i++) {
                    if (indices[i] >= 0 && indices[i] < this.priorities.length) {
                        const priority = Math.pow(Math.abs(tdErrors[i]) + this.epsilon, this.alpha);
                        this.priorities[indices[i]] = priority;
                    }
                }
            }

            size() {
                return this.buffer.length;
            }

            // Êñ∞Â¢û: Ê∏ÖÈô§‰∏ÄÈÉ®ÂàÜÊóßÁªèÈ™åÔºå‰øùÊåÅÁªèÈ™åÂ§öÊ†∑ÊÄß
            clearOldExperiences(percentage = 0.1) {
                if (this.buffer.length < 1000) return; // Âè™Âú®ÁºìÂÜ≤Âå∫ËæÉÂ§ßÊó∂ÊâßË°å

                const numToRemove = Math.floor(this.buffer.length * percentage);
                const indices = [];

                // ÁîüÊàêË¶ÅÁßªÈô§ÁöÑÈöèÊú∫Á¥¢Âºï
                for (let i = 0; i < numToRemove; i++) {
                    const idx = Math.floor(Math.random() * this.buffer.length);
                    indices.push(idx);
                }

                // ÂØπÁ¥¢ÂºïÊéíÂ∫èÂπ∂‰ªéÂêéÂêëÂâçÁßªÈô§
                indices.sort((a, b) => b - a);
                for (const idx of indices) {
                    this.buffer.splice(idx, 1);
                    this.priorities.splice(idx, 1);
                }
            }
        }

        // =========== Ornstein-UhlenbeckÂô™Â£∞ ===============
        class OUNoise {
            constructor(size, mu = 0, theta = 0.15, sigma = 0.2) {
                this.size = size;
                this.mu = mu;
                this.theta = theta;
                this.sigma = sigma;
                this.state = tf.zeros([size]);
                this.reset();
            }

            reset() {
                this.state = tf.zeros([this.size]);
            }

            sample() {
                const x = this.state;
                const dx = tf.add(
                    tf.mul(this.theta, tf.sub(this.mu, x)),
                    tf.mul(this.sigma, tf.randomNormal([this.size]))
                );
                this.state = tf.add(x, dx);
                return this.state;
            }
        }

        // ============= ‰øÆÊîπÂêéÁöÑDDPG Agent ==================
        class DDPGAgent {
            constructor(config) {
                this.config = config;
                this.maxPower = config.maxPower;
                this.roomTemp = config.roomTemp; // ‰øùÂ≠òÂÆ§Ê∏©‰æõËÆ°ÁÆóÁõ∏ÂØπÊ∏©Â∫¶

                // DDPGË∂ÖÂèÇÊï∞‰ºòÂåñ
                this.gamma = 0.99;          // Á®çÂæÆÈôç‰Ωé‰ª•ÂáèÂ∞ëÈïøÊúü‰∏çÁ°ÆÂÆöÊÄß
                this.tau = 0.005;           // Èôç‰ΩéÁõÆÊ†áÁΩëÁªúÊõ¥Êñ∞ÈÄüÁéáÔºåÂ¢ûÂä†Á®≥ÂÆöÊÄß
                this.batchSize = 64;       // Â¢ûÂ§ßÊâπÊ¨°Â§ßÂ∞è
                this.actorLr = 0.0001;      // Èôç‰ΩéÂ≠¶‰π†Áéá
                this.criticLr = 0.001;      // ‰øùÊåÅCriticÂ≠¶‰π†ÁéáËæÉÈ´ò

                // ÊûÑÂª∫ÁΩëÁªú
                this.buildNetworks();

                // ÊîπËøõÁªèÈ™åÂõûÊîæ
                this.replayBuffer = new PrioritizedReplayBuffer(50000, 0.7); // Êõ¥Â§ßÁöÑÁºìÂÜ≤Âå∫

                // ÊîπËøõÊé¢Á¥¢Á≠ñÁï•
                this.noise = new OUNoise(1, 0, 0.2, 0.6); // Œº=0, Œ∏=0.2, œÉ=0.6
                this.noiseScale = 1.0;       // Â¢ûÂ§ßÂàùÂßãÊé¢Á¥¢Á®ãÂ∫¶
                this.noiseDecay = 0.9995;    // Èôç‰ΩéÂô™Â£∞Ë°∞ÂáèÈÄüÁéá
                this.minNoiseScale = 0.1;    // ÊèêÈ´òÊúÄÂ∞èÂô™Â£∞ÈôêÂà∂

                // ÊçüÂ§±ËÆ∞ÂΩï
                this.actorLoss = 0;
                this.criticLoss = 0;

                // ËÆ≠ÁªÉÁ®≥ÂÆöÊÄßËøΩË∏™
                this.trainingStability = {
                    recentRewards: [],
                    bestReward: -Infinity,
                    noImprovementCount: 0
                };

                this.noiseAnnealingSteps = 300; // Âô™Â£∞Ë°∞ÂáèÊ≠•Êï∞Â¢ûÂä†
            }

            buildNetworks() {
                // Ê†πÊçÆÁî®Êà∑ÈÄâÊã©Âä®ÊÄÅËÆæÁΩÆÁΩëÁªúÂ±ÇÊï∞
                let numLayers = 3;
                const complexitySel = document.getElementById('modelComplexity');
                if (complexitySel) numLayers = parseInt(complexitySel.value) || 3;

                // ‰ΩøÁî®Êõ¥ÂÆΩÁöÑÁΩëÁªúÂ±Ç
                const layers = Array(numLayers).fill(96);

                // ÊûÑÂª∫ActorÁΩëÁªú - Â¢ûÂä†ËæìÂÖ•Áª¥Â∫¶ÔºåÂåÖÂê´Áõ∏ÂØπÊ∏©Â∫¶
                this.actor = this.createActor(layers);
                this.targetActor = this.createActor(layers);

                // ÊûÑÂª∫CriticÁΩëÁªú
                this.critic = this.createCritic(layers);
                this.targetCritic = this.createCritic(layers);

                // ÂàùÂßãÂåñÁõÆÊ†áÁΩëÁªú
                this.updateTargetNetworks(1.0);
            }

            createActor(layers) {
                const model = tf.sequential();
                // Â¢ûÂä†ËæìÂÖ•Áª¥Â∫¶ÔºåÂä†ÂÖ•Áõ∏ÂØπÊ∏©Â∫¶Âõ†Â≠ê
                model.add(tf.layers.dense({
                    inputShape: [4],
                    units: layers[0],
                    activation: 'relu',
                    kernelInitializer: tf.initializers.heNormal()
                }));

                // Ê∑ªÂä†ÊâπÈáèÂΩí‰∏ÄÂåñ‰ª•ÊèêÈ´òËÆ≠ÁªÉÁ®≥ÂÆöÊÄß
                model.add(tf.layers.batchNormalization());

                for (let i = 1; i < layers.length; i++) {
                    model.add(tf.layers.dense({
                        units: layers[i],
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }));

                    if (i < layers.length - 1) {
                        model.add(tf.layers.batchNormalization());
                    }
                }

                model.add(tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid',   // ËæìÂá∫Áõ¥Êé• 0-1
                    kernelInitializer: tf.initializers.glorotNormal()
                }));

                model.compile({
                    loss: tf.losses.meanSquaredError,
                    optimizer: tf.train.adam(this.actorLr)
                });

                return model;
            }

            createCritic(layers) {
                // Áä∂ÊÄÅËæìÂÖ•Â¢ûÂä†Áõ∏ÂØπÊ∏©Â∫¶Âõ†Â≠ê
                const stateInput = tf.input({ shape: [4] });
                const actionInput = tf.input({ shape: [1] });

                let stateH = tf.layers.dense({
                    units: layers[0],
                    activation: 'relu',
                    kernelInitializer: 'heNormal'
                }).apply(stateInput);

                // Ê∑ªÂä†ÊâπÈáèÂΩí‰∏ÄÂåñ
                stateH = tf.layers.batchNormalization().apply(stateH);

                for (let i = 1; i < layers.length; i++) {
                    stateH = tf.layers.dense({
                        units: layers[i],
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }).apply(stateH);

                    if (i < layers.length - 1) {
                        stateH = tf.layers.batchNormalization().apply(stateH);
                    }
                }

                const concat = tf.layers.concatenate().apply([stateH, actionInput]);

                let qValue = tf.layers.dense({
                    units: 64,
                    activation: 'relu',
                    kernelInitializer: 'heNormal'
                }).apply(concat);

                qValue = tf.layers.dense({
                    units: 1,
                    activation: 'linear',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(qValue);

                const model = tf.model({
                    inputs: [stateInput, actionInput],
                    outputs: qValue
                });

                model.compile({
                    optimizer: tf.train.adam(this.criticLr),
                    loss: tf.losses.huberLoss // ‰ΩøÁî®Huber LossÊèêÈ´òÁ®≥ÂÆöÊÄß
                });

                return model;
            }

            // ÊîπËøõÁä∂ÊÄÅÂΩí‰∏ÄÂåñÊñπÊ≥ï
            normalizeState(state, waterTemp, targetTemp) {
                // state = [ŒîT, lastWaterTemp, P_prev (0-1)]
                const [dT, lastT, pPrev] = state;

                // 1) ŒîT ÂΩí‰∏ÄÂåñ (span 5-25 ¬∞C)
                const span = Math.max(5, Math.min(25, targetTemp - this.roomTemp));
                const n_dT = Math.max(-1, Math.min(1, dT / span));

                // 2) ‰∏ä‰∏ÄÊ¨°Ê∞¥Ê∏©
                const n_Tprev = Math.max(-1, Math.min(1, (lastT - this.roomTemp) / 100));

                // 3) ‰∏ä‰∏ÄÊ≠•ÂäüÁéá
                const n_p = Math.max(0, Math.min(1, pPrev));

                // 4) ÁªùÂØπÊ∞¥Ê∏©
                const n_absT = (waterTemp - this.roomTemp) / 100;

                return [n_dT, n_Tprev, n_p, n_absT];
            }

            // ‰øÆÊîπÂä®‰ΩúÈÄâÊã©ÊñπÊ≥ï
            async selectAction(state, waterTemp, targetTemp, training = true) {
                const normalizedState = this.normalizeState(state, waterTemp, targetTemp);
                const stateTensor = tf.tensor2d([normalizedState]);

                let action = this.actor.predict(stateTensor);

                // Â¢ûÂº∫Êé¢Á¥¢Êú∫Âà∂
                if (training && this.noiseScale > this.minNoiseScale) {
                    const noise = this.noise.sample();
                    const scaledNoise = tf.mul(noise, this.noiseScale);
                    action = tf.add(action, scaledNoise);

                    // Â¢ûÂä†Ê∏©Â∫¶ËØØÂ∑ÆËæÉÂ§ßÊó∂ÁöÑÈ¢ùÂ§ñÊé¢Á¥¢
                    const tempError = Math.abs(waterTemp - targetTemp);
                    if (tempError > 2.0) {
                        const extraNoise = tf.randomUniform([1], -0.2, 0.2);
                        action = tf.add(action, extraNoise);
                    }
                }

                // ÈôêÂà∂Âú® [0,1]
                action = tf.clipByValue(action, 0, 1);
                const actionArray = await action.array();
                tf.dispose([stateTensor, action]);

                // È¢ùÂ§ñ: Âú®Âø´Êé•ËøëÁõÆÊ†áÊ∏©Â∫¶Êó∂Êèê‰æõÊõ¥Á≤æÁªÜÁöÑÊéßÂà∂
                const controlValue = actionArray[0][0] * this.maxPower;
                const tempError = Math.abs(waterTemp - targetTemp);
                if (!training && tempError < 1.0) {
                    // Êé•ËøëÁõÆÊ†áÊ∏©Â∫¶Êó∂Ôºå‰ΩøÁî®Êõ¥Á≤æÁªÜÁöÑÊéßÂà∂Á≠ñÁï•
                    return this.preciseControlStrategy(controlValue, waterTemp, targetTemp);
                }

                return controlValue;
            }

            // Êñ∞Â¢û: Á≤æÁªÜÊéßÊ∏©Á≠ñÁï•
            preciseControlStrategy(initialPower, waterTemp, targetTemp) {
                const error = waterTemp - targetTemp;

                // Â∑≤ÁªèÂú®ÁõÆÊ†áÊ∏©Â∫¶ÈôÑËøëÔºå‰ΩøÁî®PIÊéßÂà∂Ê®°Âºè
                if (Math.abs(error) < 0.3) {
                    // ÁÆÄÂåñÁöÑPIÊéßÂà∂Âô®
                    const kP = 300; // ÊØî‰æãÁ≥ªÊï∞
                    const power = initialPower - (error * kP);
                    return Math.max(0, Math.min(this.maxPower, power));
                }

                // ËøòÂú®Êé•ËøëËøáÁ®ã‰∏≠Ôºå‰ΩÜÂ∑≤ÁªèÂæàÊé•Ëøë
                if (error < 0 && error > -1.0) {
                    // Ê∞¥Ê∏©‰Ωé‰∫éÁõÆÊ†á„ÄÅ‰ΩÜÂæàÊé•ËøëÊó∂ÔºåÈôç‰ΩéÂäüÁéáÈÅøÂÖçËøáÂÜ≤
                    return initialPower * 0.85;
                }

                return initialPower; // ÂÖ∂‰ªñÊÉÖÂÜµ‰ΩøÁî®ÂéüÂßãÊéßÂà∂Á≠ñÁï•
            }

            // ‰ºòÂåñÂ•ñÂä±ÂáΩÊï∞Ôºå‰ΩøÂÖ∂Êõ¥ÂÖ∑ÊúâÊåáÂØºÊÄß
            calculateReward(waterTemp, targetTemp, heatingPower, lastWaterTemp, stepCount) {
                const error = waterTemp - targetTemp;
                const prevError = lastWaterTemp - targetTemp;

                // 1. Á≤æÁ°ÆÊéßÊ∏©Áä∂ÊÄÅ - È´òÂ•ñÂä±
                if (Math.abs(error) < 0.1) {
                    return 100;
                }

                // 2. Âü∫Á°ÄÂ•ñÂä±ËÆ°ÁÆó
                let reward = 0;

                // Ê∏©Â∑ÆÊîπËøõÂ•ñÂä± - ÊúÄÈáçË¶ÅÁöÑÊåáÂØº‰ø°Âè∑
                const improvement = Math.abs(prevError) - Math.abs(error);
                reward += improvement * 100; // Âº∫ÂåñÊ∏©Â∑ÆÊîπËøõÁöÑÈáçË¶ÅÊÄß

                // Ê∏©Â∑ÆÊÉ©ÁΩö - ‰ΩøÁî®ÂØπÊï∞ÊØî‰æãÔºåÂØπÂ§ßËØØÂ∑ÆÊõ¥ÊïèÊÑü
                reward -= Math.log(1 + Math.abs(error)) * 20;

                // ËøáÂÜ≤ÊÉ©ÁΩö - Êõ¥‰∏•Ê†º
                if (error > 0) {
                    reward -= Math.pow(error, 2) * 30;
                }

                // ÊéßÊ∏©Êé•ËøëÁõÆÊ†áÂå∫ÂüüÊó∂ÁöÑÈ¢ùÂ§ñÂ•ñÂä±
                if (Math.abs(error) < 1.0) {
                    reward += (1.0 - Math.abs(error)) * 20;
                }

                return reward;
            }

            remember(state, action, reward, nextState, done, waterTemp, targetTemp, nextWaterTemp) {
                // Â≠òÂÇ®Êâ©Â±ïÁä∂ÊÄÅÔºàÂåÖÂê´Áõ∏ÂØπÊ∏©Â∫¶Âõ†Â≠êÔºâ
                const experience = [
                    this.normalizeState(state, waterTemp, targetTemp),
                    action / this.maxPower,  // ÂΩí‰∏ÄÂåñÂä®‰ΩúÔºàÂäüÁéáÁ≥ªÊï∞0~1Ôºâ
                    reward,
                    this.normalizeState(nextState, nextWaterTemp, targetTemp),
                    done
                ];
                this.replayBuffer.add(experience);
            }

            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { indices, experiences, weights } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // ÂÆâÂÖ®Ê£ÄÊü•

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // ËÆ≠ÁªÉCritic
                    const nextActions = this.targetActor.predict(nextStates);
                    const nextQ = this.targetCritic.predict([nextStates, nextActions]);
                    const nextQFlat = tf.squeeze(nextQ);

                    const targetQ = tf.add(
                        rewards,
                        tf.mul(tf.mul(this.gamma, nextQFlat), dones)
                    );

                    const targetQExpanded = tf.expandDims(targetQ, 1);

                    // Â¢ûÂä†Ê¢ØÂ∫¶Ë£ÅÂâ™ÔºåÊèêÈ´òËÆ≠ÁªÉÁ®≥ÂÆöÊÄß
                    const criticHistory = await this.critic.fit(
                        [states, actions],
                        targetQExpanded,
                        {
                            epochs: 1,
                            verbose: 0,
                            batchSize: this.batchSize
                        }
                    );

                    this.criticLoss = criticHistory.history.loss[0];

                    // ËÆ≠ÁªÉActor
                    await this.trainActor(states);

                    // Êõ¥Êñ∞TDËØØÂ∑Æ‰ª•Êõ¥Êñ∞‰ºòÂÖàÁ∫ß
                    const predictedQ = this.critic.predict([states, actions]);
                    const tdErrors = tf.sub(targetQExpanded, predictedQ).arraySync().map(e => e[0]);
                    this.replayBuffer.updatePriorities(indices, tdErrors);

                    // ËΩØÊõ¥Êñ∞ÁõÆÊ†áÁΩëÁªú
                    this.updateTargetNetworks(this.tau);

                    // Ë°∞ÂáèÂô™Â£∞ - ‰ΩøÁî®‰ΩôÂº¶Ë°∞ÂáèÊõ≤Á∫ø
                    if (this.noiseScale > this.minNoiseScale) {
                        const cosDecayRate = this.noiseDecay * (1 + Math.cos(Math.PI * this.trainingStability.noImprovementCount / 30) * 0.1);
                        this.noiseScale = Math.max(
                            this.minNoiseScale,
                            this.noiseScale * cosDecayRate
                        );
                    }

                    // Ê∏ÖÁêÜÂº†Èáè
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextActions, nextQ, nextQFlat, targetQ, targetQExpanded, predictedQ]);

                    // Âë®ÊúüÊÄßÂú∞Ê∏ÖÈô§‰∏ÄÂ∞èÈÉ®ÂàÜÊóßÁªèÈ™åÔºå‰øùÊåÅÁªèÈ™åÂ§öÊ†∑ÊÄß
                    if (Math.random() < 0.01) { // 1%Ê¶ÇÁéáËß¶Âèë
                        this.replayBuffer.clearOldExperiences(0.05);
                    }

                } catch (error) {
                    console.error("ËÆ≠ÁªÉËøáÁ®ã‰∏≠Âá∫Èîô:", error);
                    // Á°Æ‰øùÊ∏ÖÁêÜÂº†ÈáèÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }

            async trainActor(states) {
                try {
                    const actorOptimizer = tf.train.adam(this.actorLr);
                    const loss = actorOptimizer.minimize(() => {
                        const predictedActions = this.actor.predict(states);
                        const qValues = this.critic.predict([states, predictedActions]);
                        return tf.neg(tf.mean(qValues));
                    }, true); // returnCost = true
                    if (loss) {
                        this.actorLoss = (await loss.data())[0];
                        loss.dispose();
                    }
                } catch (error) {
                    console.error("ActorËÆ≠ÁªÉÂá∫Èîô:", error);
                }
            }

            updateTargetNetworks(tau) {
                try {
                    // ËΩØÊõ¥Êñ∞ActorÁõÆÊ†áÁΩëÁªú
                    const actorWeights = this.actor.getWeights();
                    const targetActorWeights = this.targetActor.getWeights();

                    const newActorWeights = actorWeights.map((weight, i) => {
                        return tf.add(
                            tf.mul(weight, tau),
                            tf.mul(targetActorWeights[i], 1 - tau)
                        );
                    });

                    this.targetActor.setWeights(newActorWeights);

                    // ËΩØÊõ¥Êñ∞CriticÁõÆÊ†áÁΩëÁªú
                    const criticWeights = this.critic.getWeights();
                    const targetCriticWeights = this.targetCritic.getWeights();

                    const newCriticWeights = criticWeights.map((weight, i) => {
                        return tf.add(
                            tf.mul(weight, tau),
                            tf.mul(targetCriticWeights[i], 1 - tau)
                        );
                    });

                    this.targetCritic.setWeights(newCriticWeights);
                } catch (error) {
                    console.error("Êõ¥Êñ∞ÁõÆÊ†áÁΩëÁªúÂá∫Èîô:", error);
                }
            }

            // Â¢ûÂä†ËÆ≠ÁªÉÁ®≥ÂÆöÊÄßÊ£ÄÊü•
            checkTrainingStability(reward) {
                this.trainingStability.recentRewards.push(reward);
                if (this.trainingStability.recentRewards.length > 10) {
                    this.trainingStability.recentRewards.shift();
                }

                if (reward > this.trainingStability.bestReward) {
                    this.trainingStability.bestReward = reward;
                    this.trainingStability.noImprovementCount = 0;
                    return false;
                } else {
                    this.trainingStability.noImprovementCount++;

                    // ÈïøÊó∂Èó¥Ê≤°ÊúâÊîπËøõÔºåÈáçÁΩÆÂô™Â£∞ËøõË°åÊõ¥Â§öÊé¢Á¥¢
                    if (this.trainingStability.noImprovementCount > 20) {
                        // ‰∏çÁõ¥Êé•ËÆæÁΩÆÂõ∫ÂÆöÂÄºÔºåËÄåÊòØÁõ∏ÂØπÂ¢ûÂä†ÔºåÈÅøÂÖçËøáÂ§ßÊ≥¢Âä®
                        this.noiseScale = Math.min(1.0, this.noiseScale * 1.5);
                        // ÈáçÁΩÆOUÂô™Â£∞Áä∂ÊÄÅÔºåÂºïÂÖ•Êõ¥Â§öÈöèÊú∫ÊÄß
                        this.noise.reset();
                        this.trainingStability.noImprovementCount = 0;
                        return true; // Ë°®Á§∫Â∑≤ÈáçÁΩÆ
                    }
                }
                return false;
            }
        }

        /****************************************************************
         *                     TD3  Agent (Âèå Critic)                    *
         ****************************************************************/
        class TD3Agent extends DDPGAgent {
            constructor(config) {
                super(config);
                // È¢ùÂ§ñÁ¨¨‰∫åÂ•ó Critic / targetCritic
                this.critic2 = this.createCritic([96, 96, 96]);
                this.targetCritic2 = this.createCritic([96, 96, 96]);
                this.updateTargetNetworks(1.0);
                // TD3 ÁâπÊúâË∂ÖÂèÇÊï∞
                this.policyDelay = 2;     // ÊØè 2 Ê≠•Êõ¥Êñ∞‰∏ÄÊ¨° Actor
                this.policyNoise = 0.2;   // ÁõÆÊ†áÁ≠ñÁï•Âπ≥ÊªëÂô™Â£∞
                this.policyNoiseClip = 0.5;
                this.trainStep = 0;
            }

            /** Â§çÂÜô replayÔºö‰ΩøÁî®Âèå Critic + Âª∂Ëøü Actor Êõ¥Êñ∞ */
            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { indices, experiences } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // ÂÆâÂÖ®Ê£ÄÊü•

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // ÁõÆÊ†áÂä®‰Ωú + Âπ≥ÊªëÂô™Â£∞
                    let nextActions = this.targetActor.predict(nextStates);
                    const noise = tf.randomNormal(nextActions.shape, 0, this.policyNoise);
                    const clippedNoise = tf.clipByValue(noise, -this.policyNoiseClip, this.policyNoiseClip);
                    nextActions = tf.clipByValue(tf.add(nextActions, clippedNoise), 0, 1);

                    // ‰∏§‰∏™ Critic ÂèñÊúÄÂ∞è Q
                    const nextQ1 = tf.squeeze(this.targetCritic.predict([nextStates, nextActions]));
                    const nextQ2 = tf.squeeze(this.targetCritic2.predict([nextStates, nextActions]));
                    const nextQ = tf.minimum(nextQ1, nextQ2);

                    const targetQ = tf.add(rewards, tf.mul(this.gamma, tf.mul(nextQ, dones)));
                    const targetQExp = tf.expandDims(targetQ, 1);

                    // Êõ¥Êñ∞‰∏§‰∏™ Critic
                    const criticLoss1 = await this.critic.fit([states, actions], targetQExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    const criticLoss2 = await this.critic2.fit([states, actions], targetQExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    this.criticLoss = (criticLoss1.history.loss[0] + criticLoss2.history.loss[0]) / 2;

                    // ÊØè policyDelay Ê≠•Êõ¥Êñ∞‰∏ÄÊ¨° Actor
                    if (this.trainStep % this.policyDelay === 0) {
                        await this.trainActor(states);
                        // ËΩØÊõ¥Êñ∞ÊâÄÊúâ target ÁΩëÁªú
                        this.updateTargetNetworks(this.tau);
                        // Âè¶Â§ñÊõ¥Êñ∞Á¨¨‰∫åÂ•ó Critic ÁõÆÊ†á
                        const c2W = this.critic2.getWeights(),
                            tc2W = this.targetCritic2.getWeights(),
                            newW2 = c2W.map((w, i) => tf.add(tf.mul(w, this.tau), tf.mul(tc2W[i], 1 - this.tau)));
                        this.targetCritic2.setWeights(newW2);
                    }
                    this.trainStep++;

                    // Ë°∞ÂáèÂô™Â£∞ - ‰ΩøÁî®‰ΩôÂº¶Ë°∞ÂáèÊõ≤Á∫ø
                    if (this.noiseScale > this.minNoiseScale) {
                        const cosDecayRate = this.noiseDecay * (1 + Math.cos(Math.PI * this.trainingStability.noImprovementCount / 30) * 0.1);
                        this.noiseScale = Math.max(
                            this.minNoiseScale,
                            this.noiseScale * cosDecayRate
                        );
                    }

                    // Ê∏ÖÁêÜÂº†Èáè
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextActions, nextQ1, nextQ2, nextQ, targetQ, targetQExp]);
                } catch (error) {
                    console.error("TD3 ËÆ≠ÁªÉËøáÁ®ã‰∏≠Âá∫Èîô:", error);
                    // Á°Æ‰øùÊ∏ÖÁêÜÂº†ÈáèÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }
        }

        /****************************************************************
         *                     SAC  Agent (ÊúÄÂ§ßÁÜµ)                       *
         ****************************************************************/
        class SACAgent extends DDPGAgent {
            constructor(config) {
                super(config);
                // Ë¶ÜÁõñ actor ‰∏∫ Gaussian policyÔºöËæìÂá∫ Œº, logœÉ
                this.actor = this.createGaussianActor([96, 96, 96]);
                this.targetActor = this.createGaussianActor([96, 96, 96]);
                this.updateTargetNetworks(1.0);

                // SAC ÁâπÊúâË∂ÖÂèÇÊï∞
                this.alpha = 0.2;   // ÁÜµÊ∏©Â∫¶ÔºåÂèØËÆ≠ÁªÉ‰πüÂèØÂõ∫ÂÆö
                this.targetEntropy = -1; // ÁªèÈ™åÊ≥ïÔºö-|A|
                this.logAlpha = tf.variable(tf.scalar(Math.log(this.alpha)));
                this.alphaOpt = tf.train.adam(3e-4);

                // ‰∏∫SACÂàõÂª∫Á¨¨‰∫å‰∏™critic
                this.critic2 = this.createCritic([96, 96, 96]);
                this.targetCritic2 = this.createCritic([96, 96, 96]);
            }

            createGaussianActor(layers) {
                const input = tf.input({ shape: [4] }); // 4Áª¥ËæìÂÖ•ÔºåÂåÖÂê´Áõ∏ÂØπÊ∏©Â∫¶Á≥ªÊï∞
                let x = input;

                // Ê∑ªÂä†ÊâπÈáèÂΩí‰∏ÄÂåñ
                let normalizedInput = tf.layers.batchNormalization().apply(input);
                x = normalizedInput;

                layers.forEach((units, i) => {
                    x = tf.layers.dense({
                        units,
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }).apply(x);

                    if (i < layers.length - 1) {
                        x = tf.layers.batchNormalization().apply(x);
                    }
                });

                const mu = tf.layers.dense({
                    units: 1,
                    activation: 'tanh',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(x);

                // ÂØπlogStd‰ΩøÁî®tanhÊøÄÊ¥ªÔºåÈôêÂà∂ËæìÂá∫ËåÉÂõ¥
                const logStd = tf.layers.dense({
                    units: 1,
                    activation: 'tanh',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(x);

                // Êò†Â∞ÑtanhËæìÂá∫Âà∞ÂêàÁêÜÁöÑlogStdËåÉÂõ¥
                const scaledLogStd = tf.layers.dense({
                    units: 1,
                    activation: 'linear',
                    kernelInitializer: tf.initializers.constant({ value: 0.5 }),
                    biasInitializer: tf.initializers.constant({ value: -1.0 })
                }).apply(logStd); // Â∞ÜtanhËæìÂá∫Êò†Â∞ÑÂà∞[-2, 0]ËåÉÂõ¥

                const model = tf.model({ inputs: input, outputs: [mu, scaledLogStd] });
                return model;
            }

            /** ÈááÊ†∑Âä®‰ΩúÔºöre‚Äëparameterization + tanh squash */
            async selectAction(state, waterTemp, targetTemp, training = true) {
                try {
                    const ns = this.normalizeState(state, waterTemp, targetTemp);
                    const sTen = tf.tensor2d([ns]);
                    const [mu, logStd] = this.actor.predict(sTen);

                    // ÈôêÂà∂logStdËåÉÂõ¥ÔºåÈÅøÂÖçÊï∞ÂÄº‰∏çÁ®≥ÂÆö
                    const clippedLogStd = tf.clipByValue(logStd, -20, 2);
                    const std = tf.exp(clippedLogStd);

                    let action;
                    if (training) {
                        const eps = tf.randomNormal(std.shape);
                        action = tf.add(mu, tf.mul(std, eps)); // re‚Äëparameterization
                    } else {
                        action = mu; // ÊµãËØïÊó∂Áõ¥Êé•‰ΩøÁî®ÂùáÂÄº
                    }

                    action = tf.tanh(action);                  // squash to [-1,1]
                    action = tf.div(tf.add(action, 1), 2);     // -> [0,1]

                    // Á°Æ‰øùÂä®‰ΩúÂú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
                    action = tf.clipByValue(action, 0, 1);

                    const arr = await action.array();
                    tf.dispose([sTen, mu, logStd, clippedLogStd, std, action]);

                    // ËøîÂõûÁº©ÊîæÂêéÁöÑÂäüÁéá
                    const powerValue = arr[0][0] * this.maxPower;

                    // Âú®ÊµãËØïÊ®°Âºè‰∏ã‰ΩøÁî®Á≤æÁ°ÆÊéßÂà∂
                    if (!training && Math.abs(waterTemp - targetTemp) < 1.0) {
                        return this.preciseControlStrategy(powerValue, waterTemp, targetTemp);
                    }

                    return powerValue;
                } catch (error) {
                    console.error("SACÂä®‰ΩúÈÄâÊã©Âá∫Èîô:", error);
                    // Âá∫ÈîôÊó∂ËøîÂõû‰∏Ä‰∏™ÂÆâÂÖ®ÁöÑÈªòËÆ§ÂÄº
                    return this.maxPower * 0.5;
                }
            }

            /** Ë¶ÜÂÜô replayÔºö2 Critic + entropy ÁõÆÊ†á */
            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { experiences } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // ÂÆâÂÖ®Ê£ÄÊü•

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // -------- ËÆ°ÁÆóÁõÆÊ†á Q --------
                    const [nextMu, nextLogStd] = this.actor.predict(nextStates);
                    const clippedLogStd = tf.clipByValue(nextLogStd, -20, 2);
                    const nextStd = tf.exp(clippedLogStd);
                    const nextEps = tf.randomNormal(nextStd.shape);
                    let nextAction = tf.add(nextMu, tf.mul(nextStd, nextEps));
                    nextAction = tf.tanh(nextAction);
                    const nextActS = tf.div(tf.add(nextAction, 1), 2); // [0,1]

                    // ËÆ°ÁÆólogÊ¶ÇÁéá - Êõ¥Á®≥ÂÆöÁöÑÂÆûÁé∞
                    const logProb = tf.sub(
                        tf.sum(
                            tf.sub(
                                tf.sub(
                                    tf.mul(-0.5, tf.square(nextEps)),
                                    nextLogStd
                                ),
                                tf.scalar(0.5 * Math.log(2 * Math.PI))
                            ),
                            1, true
                        ),
                        tf.sum(
                            tf.log(tf.sub(tf.scalar(1.0), tf.square(tf.tanh(nextAction)))).add(tf.scalar(1e-6)),
                            1, true
                        )
                    );

                    const targetQ1 = tf.squeeze(this.targetCritic.predict([nextStates, nextActS]));
                    const targetQ2 = tf.squeeze(this.targetCritic2.predict([nextStates, nextActS]));
                    const minTargetQ = tf.minimum(targetQ1, targetQ2);

                    const target = tf.add(rewards,
                        tf.mul(this.gamma,
                            tf.mul(dones,
                                tf.sub(minTargetQ, tf.mul(this.alpha, logProb.squeeze())))));

                    // -------- Êõ¥Êñ∞‰∏§ Critic --------
                    const targetExp = tf.expandDims(target, 1);
                    const loss1 = await this.critic.fit([states, actions], targetExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    const loss2 = await this.critic2.fit([states, actions], targetExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    this.criticLoss = (loss1.history.loss[0] + loss2.history.loss[0]) / 2;

                    // -------- Êõ¥Êñ∞ Actor & Œ± --------
                    const actorOpt = tf.train.adam(this.actorLr);
                    await actorOpt.minimize(() => {
                        const [mu, lstd] = this.actor.predict(states);
                        const cLstd = tf.clipByValue(lstd, -20, 2);
                        const std = tf.exp(cLstd);
                        const eps = tf.randomNormal(std.shape);
                        let act = tf.add(mu, tf.mul(std, eps));
                        act = tf.tanh(act);
                        const actS = tf.div(tf.add(act, 1), 2);

                        const logPi = tf.sub(
                            tf.sum(
                                tf.sub(
                                    tf.sub(
                                        tf.mul(-0.5, tf.square(eps)),
                                        lstd
                                    ),
                                    tf.scalar(0.5 * Math.log(2 * Math.PI))
                                ),
                                1, true
                            ),
                            tf.sum(
                                tf.log(tf.sub(tf.scalar(1.0), tf.square(tf.tanh(act)))).add(tf.scalar(1e-6)),
                                1, true
                            )
                        );

                        const q1 = this.critic.predict([states, actS]);
                        const q2 = this.critic2.predict([states, actS]);
                        const minQ = tf.minimum(q1, q2);

                        const actorLoss = tf.mean(tf.mul(this.alpha, logPi).sub(minQ));
                        // Œ± Ê∏©Â∫¶Êõ¥Êñ∞
                        const alphaLoss = tf.mean(
                            tf.mul(this.logAlpha, tf.neg(logPi).sub(this.targetEntropy)));
                        this.alphaOpt.minimize(() => alphaLoss, false, [this.logAlpha]);
                        this.alpha = Math.exp((this.logAlpha.dataSync())[0]);

                        mu.dispose(); lstd.dispose(); cLstd.dispose(); std.dispose(); eps.dispose();
                        act.dispose(); actS.dispose(); logPi.dispose(); q1.dispose();
                        q2.dispose(); minQ.dispose(); // keep actorLoss

                        return actorLoss;
                    }, false /* return cost */);

                    // ËΩØÊõ¥Êñ∞ÁõÆÊ†áÁΩëÁªú
                    this.updateTargetNetworks(this.tau);
                    const c2W = this.critic2.getWeights(), tc2W = this.targetCritic2.getWeights(),
                        newW2 = c2W.map((w, i) => tf.add(tf.mul(w, this.tau), tf.mul(tc2W[i], 1 - this.tau)));
                    this.targetCritic2.setWeights(newW2);

                    // Ê∏ÖÁêÜÂº†Èáè
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextMu, nextLogStd, clippedLogStd, nextStd, nextEps, nextAction, nextActS,
                        logProb, targetQ1, targetQ2, minTargetQ, target, targetExp]);
                } catch (error) {
                    console.error("SACËÆ≠ÁªÉËøáÁ®ã‰∏≠Âá∫Èîô:", error);
                    // Á°Æ‰øùÊ∏ÖÁêÜÂº†ÈáèÈÅøÂÖçÂÜÖÂ≠òÊ≥ÑÊºè
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }
        }

        // ============= ‰∏ªÊéßÂà∂Âô® ==================
        class MLController {
            constructor() {
                this.logContainer = document.getElementById('logContainer');
                this.setupEventListeners();
                this.setupCharts();
                this.isTraining = false;
                this.testSimulating = false;
                this.ddpgAgent = null;

                // ËÆ≠ÁªÉÊåáÊ†áËÆ∞ÂΩï
                this.trainingMetrics = {
                    episodeErrors: [],
                    episodeRewards: []
                };

            }

            setupCharts() {
                // Ê£ÄÊü•ChartÊòØÂê¶Â∑≤Âä†ËΩΩ
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    return;
                }

                const ctx = document.getElementById('lossChart').getContext('2d');
                this.lossChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ÊÄªÂ•ñÂä±',
                            data: [],
                            borderColor: '#4CAF50',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'ËÆ≠ÁªÉÂ•ñÂä±ÂèòÂåñ'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: { display: true, text: 'Â•ñÂä±ÂÄº' }
                            },
                            x: {
                                title: { display: true, text: 'ËÆ≠ÁªÉËΩÆÊ¨°' }
                            }
                        }
                    }
                });

                const tdCtx = document.getElementById('tdLossChart').getContext('2d');
                this.tdLossChart = new Chart(tdCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ActorÊçüÂ§±',
                            data: [],
                            borderColor: '#FF5722',
                            backgroundColor: 'rgba(255, 87, 34, 0.1)',
                            tension: 0.1,
                            fill: true
                        },
                        {
                            label: 'CriticÊçüÂ§±',
                            data: [],
                            borderColor: '#2196F3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Actor/CriticÊçüÂ§±ÂèòÂåñ'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'ÊçüÂ§±ÂÄº' }
                            },
                            x: {
                                title: { display: true, text: 'ËÆ≠ÁªÉËΩÆÊ¨°' }
                            }
                        }
                    }
                });

                // ËÆ≠ÁªÉÂêéÊ∞¥Ê∏©Êõ≤Á∫ø
                const trainCtx = document.getElementById('trainCurveChart').getContext('2d');
                this.trainCurveChart = new Chart(trainCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'ÁõÆÊ†áÊ∏©Â∫¶',          // Êï∞ÊçÆÈõÜ 0
                                data: [],
                                borderColor: '#FF9800',
                                backgroundColor: 'rgba(255,152,0,0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                yAxisID: 'temp'
                            },
                            {
                                label: 'Ê∞¥Ê∏©ËΩ®Ëøπ',          // Êï∞ÊçÆÈõÜ 1
                                data: [],
                                borderColor: '#4CAF50',
                                backgroundColor: 'rgba(76,175,80,0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                yAxisID: 'temp'
                            },
                            {
                                label: 'Â•ñÂä±',              // ‚≠ê Êñ∞Â¢ûÊï∞ÊçÆÈõÜ 2
                                data: [],
                                borderColor: '#2196F3',
                                backgroundColor: 'rgba(33,150,243,0.05)',
                                fill: true,
                                tension: 0.2,
                                borderWidth: 1,
                                yAxisID: 'reward'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        interaction: { intersect: false, mode: 'index' },
                        plugins: {
                            legend: { position: 'top' },
                            title: { display: true, text: 'ÊØèËΩÆËÆ≠ÁªÉÂêéÊ∞¥Ê∏©‰∏éÂ•ñÂä±ÂìçÂ∫î' }
                        },
                        scales: {
                            temp: {                       // üå°Ô∏è Ê∏©Â∫¶‰∏ªËΩ¥ÔºàÂ∑¶Ôºâ
                                type: 'linear',
                                position: 'left',
                                beginAtZero: false,
                                title: { display: true, text: 'Ê∏©Â∫¶ (¬∞C)' }
                            },
                            reward: {                     // üí∞ Â•ñÂä±ÂâØËΩ¥ÔºàÂè≥Ôºâ
                                type: 'linear',
                                position: 'right',
                                beginAtZero: true,
                                grid: { drawOnChartArea: false },
                                title: { display: true, text: 'Â•ñÂä±' }
                            },
                            x: {
                                title: { display: true, text: 'Êó∂Èó¥Ê≠•' }
                            }
                        }
                    }
                });
                const testCtx = document.getElementById('testCurveChart').getContext('2d');
                this.testCurveChart = new Chart(testCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'ÁõÆÊ†áÊ∏©Â∫¶',
                                data: [],
                                borderColor: '#FF9800',
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'ÂÆûÈôÖÊ∞¥Ê∏©',
                                data: [],
                                borderColor: '#2196F3',
                                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'Âä†ÁÉ≠ÂäüÁéá',
                                data: [],
                                borderColor: '#9C27B0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                fill: false,
                                tension: 0.1,
                                yAxisID: 'power',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'ÂÆûÊó∂ÊéßÊ∏©ËøáÁ®ã'
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: { display: true, text: 'Ê∏©Â∫¶ (¬∞C)' }
                            },
                            power: {
                                type: 'linear',
                                position: 'right',
                                beginAtZero: true,
                                title: { display: true, text: 'ÂäüÁéá (W)' },
                                grid: { drawOnChartArea: false }
                            },
                            x: {
                                title: { display: true, text: 'Êó∂Èó¥Ê≠•' }
                            }
                        }
                    }
                });

                // Êñ∞Â¢û: Ê∏©Â∫¶ËØØÂ∑ÆÊõ≤Á∫ø
                const errorCtx = document.getElementById('errorChart').getContext('2d');
                this.errorChart = new Chart(errorCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Âπ≥ÂùáÊ∏©Â∫¶ËØØÂ∑Æ',
                                data: [],
                                borderColor: '#E91E63',
                                backgroundColor: 'rgba(233, 30, 99, 0.1)',
                                fill: true,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'ÊúÄÂ§ßÊ∏©Â∫¶ËØØÂ∑Æ',
                                data: [],
                                borderColor: '#FF5722',
                                backgroundColor: 'rgba(255, 87, 34, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'ËÆ≠ÁªÉËøáÁ®ãÊ∏©Â∫¶ËØØÂ∑ÆÂèòÂåñ'
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'Ê∏©Â∫¶ËØØÂ∑Æ (¬∞C)' }
                            },
                            x: {
                                title: { display: true, text: 'ËÆ≠ÁªÉËΩÆÊ¨°' }
                            }
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startTraining').addEventListener('click',
                    () => this.startTraining());
                document.getElementById('stopTraining').addEventListener('click',
                    () => this.stopTraining());
                document.getElementById('saveModel').addEventListener('click',
                    () => this.saveModel());
                document.getElementById('loadModel').addEventListener('click',
                    () => this.loadModel());
                document.getElementById('testModel').addEventListener('click',
                    () => this.testModel());
                document.getElementById('stopTest').addEventListener('click',
                    () => this.stopTestModel());
            }

            log(message, type = 'info') {
                const logContainer = this.logContainer;
                const timestamp = new Date().toLocaleTimeString();
                let color = '#666';

                if (type === 'success') color = '#4CAF50';
                if (type === 'warning') color = '#FF9800';
                if (type === 'error') color = '#F44336';

                logContainer.innerHTML += `<span style="color: ${color};">[${timestamp}]</span> ${message}<br>`;
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }

            updateProgressBar(current, total) {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const percent = Math.round((current / total) * 100);

                progressBar.style.width = `${percent}%`;
                progressText.textContent = `${percent}% (${current}/${total})`;
                document.getElementById('trainingProgress').style.display = 'block';
            }

            updateTrainingMetrics(episode, totalEpisodes, reward, noise, tempErrors) {
                document.getElementById('currentEpisode').textContent = `${episode}/${totalEpisodes}`;
                document.getElementById('currentNoise').textContent = `${(noise * 100).toFixed(1)}%`;

                // ËÆ°ÁÆóÂπ≥ÂùáÂ•ñÂä±
                const avgReward = this.trainingMetrics.episodeRewards
                    .slice(-10)
                    .reduce((sum, val) => sum + val, 0) /
                    Math.min(10, this.trainingMetrics.episodeRewards.length);
                document.getElementById('avgReward').textContent = avgReward.toFixed(1);

                // ËÆ°ÁÆóÂπ≥ÂùáËØØÂ∑Æ
                let avgError = 0;
                if (tempErrors && tempErrors.length > 0) {
                    avgError = tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length;
                }
                document.getElementById('avgError').textContent = avgError.toFixed(2);
            }

            updateMetrics(temp, error, power, reward) {
                document.getElementById('currentTemp').textContent = temp.toFixed(1);
                document.getElementById('currentError').textContent = error.toFixed(2);
                document.getElementById('currentPower').textContent = power.toFixed(0);
                document.getElementById('currentReward').textContent = reward.toFixed(1);
                document.getElementById('metricsPanel').style.display = 'block';
            }

            /**  ËÆ≠ÁªÉÂêéÂø´ÈÄüÊ®°Êãü‰∏ÄÊ¨°ÂçáÊ∏©Êõ≤Á∫øÔºåÁî®‰∫éÂèØËßÜÂåñÊîπËøõÊïàÊûú  */
            async evaluateTrainingCurve(agent, config, targetTemp, maxSimSteps = 600) {
                // targetTemp ÂøÖÈ°ªÁî±Ë∞ÉÁî®Êñπ‰º†ÂÖ•ÔºàÊØèËΩÆ‰∏çÂêåÔºâÔºå‰∏çÂèØÂÜçÁî® config.targetTemp
                let waterTemp = config.initTemp;
                let lastWaterTemp = waterTemp;
                let dTdt = 0;
                let lastPower = 0;
                const rewardTrace = [];
                const tempTrace = [];
                const tempErrors = [];
                // ÁõÆÊ†áÊ∏©Â∫¶Êõ≤Á∫øÂÖ®Á®ãÁî®‰º†ÂÖ•ÁöÑ targetTemp
                const setTrace = Array(maxSimSteps).fill(targetTemp);

                for (let step = 0; step < maxSimSteps; step++) {
                    // Ê†∏ÂøÉ3Èáè + Ê∞¥Ê∏©ÂíåÁõÆÊ†áÊ∏©Â∫¶
                    const state = [
                        waterTemp - targetTemp,
                        lastWaterTemp,
                        lastPower / agent.maxPower
                    ];

                    const power = await agent.selectAction(state, waterTemp, targetTemp, false);

                    // ÁéØÂ¢ÉÊ®°Âûã
                    const deltaT = (power - config.hA * (waterTemp - config.roomTemp)) /
                        (config.waterMass * 4184);
                    const nextTemp = waterTemp + deltaT;
                    dTdt = (nextTemp - waterTemp) / config.deltaT;
                    lastWaterTemp = waterTemp;
                    waterTemp = nextTemp;
                    lastPower = power;
                    tempTrace.push(waterTemp);

                    // ËÆ°ÁÆóÊ∏©Â∫¶ËØØÂ∑Æ
                    const error = Math.abs(waterTemp - targetTemp);
                    tempErrors.push(error);

                    const reward = agent.calculateReward(waterTemp, targetTemp, power, lastWaterTemp, step);
                    rewardTrace.push(reward);

                    if (error < 0.1 && step > 200) break;
                }

                if (this.trainCurveChart) {
                    this.trainCurveChart.data.labels = tempTrace.map((_, i) => i);
                    // ÁõÆÊ†áÊ∏©Â∫¶ËΩ®ËøπÂøÖÈ°ªÂÖ®Á®ãÁî®‰º†ÂÖ•ÁöÑ targetTemp
                    this.trainCurveChart.data.datasets[0].data = setTrace.slice(0, tempTrace.length);
                    this.trainCurveChart.data.datasets[1].data = tempTrace;
                    this.trainCurveChart.data.datasets[2].data = rewardTrace;
                    
                    this.trainCurveChart.update('none');

                }

                return {
                    avgError: tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length,
                    maxError: Math.max(...tempErrors),
                    finalError: tempErrors[tempErrors.length - 1],
                    stepCount: tempTrace.length
                };
            }

            async startTraining() {
                const algorithm = document.getElementById('algorithmSelect').value;
                if (this.isTraining) return;

                this.isTraining = true;
                this.updateStatus(`üöÄ ${algorithm.toUpperCase()} Âº∫ÂåñÂ≠¶‰π†ËÆ≠ÁªÉ‰∏≠...`);

                // ÈáçÁΩÆËÆ≠ÁªÉÊåáÊ†á
                this.trainingMetrics = {
                    episodeErrors: [],
                    episodeRewards: []
                };

                if (this.lossChart) {
                    this.lossChart.data.labels = [];
                    this.lossChart.data.datasets[0].data = [];
                    this.lossChart.update();
                }

                if (this.tdLossChart) {
                    this.tdLossChart.data.labels = [];
                    this.tdLossChart.data.datasets[0].data = [];
                    this.tdLossChart.data.datasets[1].data = [];
                    this.tdLossChart.update();
                }

                if (this.errorChart) {
                    this.errorChart.data.labels = [];
                    this.errorChart.data.datasets[0].data = [];
                    this.errorChart.data.datasets[1].data = [];
                    this.errorChart.update();
                }

                const config = {
                    maxPower: parseFloat(document.getElementById('maxPowerInput').value),
                    targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),   // ‰ªÖÊµãËØïÈò∂ÊÆµ‰ΩøÁî®
                    initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                    roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                    hA: parseFloat(document.getElementById('hAInput').value),
                    waterMass: parseFloat(document.getElementById('waterMassInput').value),
                    deltaT: parseFloat(document.getElementById('deltaT').value)
                };

                // Á¶ÅÊ≠¢ËÆ≠ÁªÉÊúüÈó¥‰ΩøÁî®Âõ∫ÂÆö targetTemp
                config.targetTemp = null;

                // Âä®ÊÄÅËÆ°ÁÆóÂêàÁêÜÁöÑÁõÆÊ†áÊ∏©Â∫¶ËåÉÂõ¥ÔºåÂü∫‰∫éÁéØÂ¢ÉÊ∏©Â∫¶ÂíåÊúÄÂ§ßÂäüÁéá
                const minTemp = Math.max(25, config.roomTemp + 5); // Ëá≥Â∞ëÈ´ò‰∫éÂÆ§Ê∏©5Â∫¶
                const maxTemp = Math.min(95, config.roomTemp + config.maxPower / 40); // Âü∫‰∫éÊúÄÂ§ßÂäüÁéáÁöÑÂèØËææÊ∏©Â∫¶
                config.targetMin = minTemp;
                config.targetMax = maxTemp;

                this.log(`üéØ ÂºÄÂßã ${algorithm.toUpperCase()} Êô∫ËÉΩÊéßÊ∏©ËÆ≠ÁªÉ...`);
                this.log(`üìä ËÆ≠ÁªÉÁõÆÊ†áÊ∏©Âå∫Âä®ÊÄÅË∞ÉÊï¥‰∏∫: ${minTemp.toFixed(1)}‚Äë${maxTemp.toFixed(1)}¬∞CÔºåÂü∫‰∫éÂÆ§Ê∏©${config.roomTemp}¬∞C`);

                let episodeTarget = null;
                try {
                    if (algorithm === 'td3') {
                        this.ddpgAgent = new TD3Agent(config);
                    } else if (algorithm === 'sac') {
                        this.ddpgAgent = new SACAgent(config);
                    } else {
                        this.ddpgAgent = new DDPGAgent(config);
                    }

                    const nEpisodes = parseInt(document.getElementById('epochs').value) || 200;
                    // === Âõ∫ÂÆöÂõûÂêàÊ≠•Êï∞Ôºå‰∏ìÊ≥®ÂÖàÊääËÆ≠ÁªÉË∑ëÈÄö ===
                    const maxSteps = 2000;                // ÊØèÂõûÂêà 2000 Ê≠•
                    console.log(`üí° Episode duration fixed at ${maxSteps} steps`);
                    const tolerance = 0.05;          // ÁõÆÊ†áÁ®≥ÊÄÅÁ≤æÂ∫¶ ¬±0.05 ¬∞C

                    let bestReward = -Infinity;
                    let bestActorWeights = null;
                    let bestCriticWeights = null;
                    let recentRewards = [];

                    let lastPower = 0;
                    // === ÂèåÈò∂ÊÆµ: ÂçáÊ∏© + Á®≥ÊÄÅËÄÉÂØü ===
                    const steadyNeeded = 500;         // Á®≥ÊÄÅÈúÄÊåÅÁª≠Ê≠•Êï∞

                    for (let episode = 0; episode < nEpisodes; episode++) {
                        if (!this.isTraining) {
                            this.updateStatus('‚ùå ËÆ≠ÁªÉÂ∑≤ÂÅúÊ≠¢');
                            this.log('‚èπÔ∏è ËÆ≠ÁªÉË¢´Áî®Êà∑‰∏≠Ê≠¢');
                            return;
                        }

                        // Êõ¥Êñ∞ËÆ≠ÁªÉËøõÂ∫¶Êù°
                        this.updateProgressBar(episode + 1, nEpisodes);

                        // ÂÆûÁé∞ËØæÁ®ãÂ≠¶‰π† - Âæ™Â∫èÊ∏êËøõÊèêÈ´òÈöæÂ∫¶
                        let episodeTargetRange;
                        if (episode < nEpisodes * 0.3) {
                            // Ââç30%ËΩÆÊ¨°ÔºöÂú®ËæÉÁ™ÑËåÉÂõ¥ÂÜÖËÆ≠ÁªÉ
                            const targetMid = (config.targetMin + config.targetMax) / 2;
                            const narrowRange = (config.targetMax - config.targetMin) * 0.3;
                            episodeTarget = targetMid - narrowRange / 2 + Math.random() * narrowRange;
                        } else {
                            // ÂêéÁª≠ÈÄêÊ≠•Êâ©Â§ßËåÉÂõ¥
                            const progress = Math.min(1.0, (episode - nEpisodes * 0.3) / (nEpisodes * 0.7));
                            const range = (config.targetMax - config.targetMin) * (0.3 + 0.7 * progress);
                            const targetMid = (config.targetMin + config.targetMax) / 2;
                            episodeTarget = targetMid - range / 2 + Math.random() * range;
                        }

                        // Âä®ÊÄÅË∞ÉÊï¥ÂàùÂßãÊ∞¥Ê∏© - Èù†Ëøë‰ΩÜ‰Ωé‰∫éÁõÆÊ†áÊ∏©Â∫¶
                        let waterTemp = config.roomTemp + (episodeTarget - config.roomTemp) * (0.3 + 0.5 * Math.random());

                        let dTdt = 0;
                        let lastWaterTemp = waterTemp;
                        let state = [waterTemp - episodeTarget, lastWaterTemp, 0];
                        let totalReward = 0;

                        // Ëã•Êú¨ÂõûÂêàÊú™ËÉΩËøõÂÖ•ÂÆπÂ∑ÆÂå∫Èó¥ÔºåÂàô‰øùÊåÅ null ‚ûú Êó•ÂøóÊòæÁ§∫"Êú™Ëææ"
                        let stepsToTarget = null;
                        let warmUpDone = false;
                        let steadySteps = 0;

                        let stableCount = 0;
                        // Êî∂ÈõÜÊ∏©Â∫¶ËØØÂ∑Æ
                        const tempErrors = [];

                        for (let step = 0; step < maxSteps; step++) {
                            if (!this.isTraining) break;

                            // Êõ¥Êñ∞ÂêéÁöÑ selectAction ‰º†ÂÖ•ÂΩìÂâçÊ∞¥Ê∏©ÂíåÁõÆÊ†áÊ∏©Â∫¶
                            const heatingPower = await this.ddpgAgent.selectAction(state, waterTemp, episodeTarget, true);
                            const deltaT = (heatingPower - config.hA * (waterTemp - config.roomTemp)) / (config.waterMass * 4184);
                            const nextWaterTemp = waterTemp + deltaT;
                            const nextDTdt = (nextWaterTemp - waterTemp) / config.deltaT;
                            const nextState = [
                                nextWaterTemp - episodeTarget,
                                waterTemp,
                                heatingPower / this.ddpgAgent.maxPower
                            ];

                            // ÊîπËøõÁöÑÂ•ñÂä±ÂáΩÊï∞ - Êé•Êî∂Ê∞¥Ê∏©ÂíåÁõÆÊ†áÊ∏©Â∫¶
                            const reward = this.ddpgAgent.calculateReward(nextWaterTemp, episodeTarget, heatingPower, lastWaterTemp, step);

                            // ÊîπËøõÁöÑËÆ∞ÂøÜÂáΩÊï∞Ôºå‰º†ÂÖ•Êõ¥Â§öÊ∏©Â∫¶‰ø°ÊÅØ
                            this.ddpgAgent.remember(state, heatingPower, reward, nextState, false, waterTemp, episodeTarget, nextWaterTemp);

                            lastPower = heatingPower;
                            state = nextState;
                            lastWaterTemp = waterTemp;
                            waterTemp = nextWaterTemp;
                            totalReward += reward;

                            // Êî∂ÈõÜËØØÂ∑ÆÊï∞ÊçÆ
                            const tempError = Math.abs(waterTemp - episodeTarget);
                            tempErrors.push(tempError);

                            const inTol = tempError < tolerance;

                            if (inTol && !warmUpDone) {
                                warmUpDone = true;
                                stepsToTarget = step;
                            }

                            if (warmUpDone) {
                                const tempSlope = Math.abs(nextDTdt);
                                if (tempSlope < 0.02) {
                                    steadySteps++;
                                } else {
                                    steadySteps = 0;
                                }

                                if (steadySteps >= steadyNeeded) {
                                    break;
                                }
                            }
                            if (Math.abs(waterTemp - episodeTarget) < 0.3) {
                                stableCount++;
                            } else {
                                stableCount = 0;
                            }
                            // Êñ∞ÁöÑÊèêÂâçÁªàÊ≠¢ÈÄªËæëÔºöËøõÂÖ•ÁõÆÊ†áÂå∫Èó¥ÂêéËÄÉÂØü‰∏ÄÂÆöÁ®≥ÂÆöÊó∂Èó¥
                            if (stableCount > 0 && stableCount % 50 === 0) {
                                const avgError = Math.abs(waterTemp - episodeTarget);
                                if (avgError < 0.2) {
                                    this.log(`üéØ Á¨¨${episode + 1}ËΩÆ: ÊéßÊ∏©Â∑≤Á®≥ÂÆöÂú®ÁõÆÊ†áËØØÂ∑ÆËåÉÂõ¥ÂÜÖÔºåÊèêÂâçÁªìÊùü`);
                                    break;
                                }
                            }
                        }

                        // ÊØèÂõûÂêàÁªìÊùüÂêéÂ¢ûÂä†Êõ¥Â§öÁöÑÂõûÊîæËÆ≠ÁªÉ
                        const replayCount = Math.min(10, Math.floor(episode / 20) + 1);
                        for (let i = 0; i < replayCount; i++) {
                            await this.ddpgAgent.replay();
                        }

                        // ‰øùÂ≠òËÆ≠ÁªÉÊåáÊ†á
                        this.trainingMetrics.episodeRewards.push(totalReward);
                        if (tempErrors.length > 0) {
                            const avgError = tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length;
                            const maxError = Math.max(...tempErrors);
                            this.trainingMetrics.episodeErrors.push({ avg: avgError, max: maxError });

                            // Êõ¥Êñ∞ËØØÂ∑ÆÊõ≤Á∫ø
                            if (this.errorChart) {
                                this.errorChart.data.labels.push(episode + 1);
                                this.errorChart.data.datasets[0].data.push(avgError);
                                this.errorChart.data.datasets[1].data.push(maxError);
                                this.errorChart.update('none');
                            }
                        }

                        // Êõ¥Êñ∞ËÆ≠ÁªÉÊåáÊ†áÈù¢Êùø
                        this.updateTrainingMetrics(
                            episode + 1, nEpisodes,
                            totalReward,
                            this.ddpgAgent.noiseScale,
                            tempErrors
                        );

                        recentRewards.push(totalReward);
                        if (recentRewards.length > 10) recentRewards.shift();

                        if (this.lossChart) {
                            this.lossChart.data.labels.push(episode + 1);
                            this.lossChart.data.datasets[0].data.push(totalReward);
                            this.lossChart.update('none');
                        }

                        if (this.tdLossChart) {
                            this.tdLossChart.data.labels.push(episode + 1);
                            this.tdLossChart.data.datasets[0].data.push(Math.abs(this.ddpgAgent.actorLoss || 0));
                            this.tdLossChart.data.datasets[1].data.push(this.ddpgAgent.criticLoss || 0);
                            this.tdLossChart.update('none');
                        }

                        // Ê£ÄÊü•ËÆ≠ÁªÉÁ®≥ÂÆöÊÄßÂπ∂ÂèØËÉΩÈáçÁΩÆÊé¢Á¥¢
                        const resetExploration = this.ddpgAgent.checkTrainingStability(totalReward);
                        if (resetExploration) {
                            this.log(`üîÑ Á¨¨${episode + 1}ËΩÆ: ÈáçÁΩÆÊé¢Á¥¢Á≠ñÁï•ÔºåÂ¢ûÂ§ßÂô™Â£∞Ëá≥ ${(this.ddpgAgent.noiseScale * 100).toFixed(1)}%`, 'warning');
                        }

                        if (totalReward > bestReward) {
                            bestReward = totalReward;
                            // 1Ô∏è‚É£ ÂÖàÈáäÊîæÊóßÂø´ÁÖß
                            if (bestActorWeights) bestActorWeights.forEach(t => t.dispose());
                            if (bestCriticWeights) bestCriticWeights.forEach(t => t.dispose());

                            // 2Ô∏è‚É£ clone Ê∑±Êã∑Ë¥ùÔºåÈîÅÂÆöÂø´ÁÖß
                            bestActorWeights = this.ddpgAgent.actor.getWeights().map(t => t.clone());
                            bestCriticWeights = this.ddpgAgent.critic.getWeights().map(t => t.clone());

                            this.log(`üèÜ Á¨¨${episode + 1}ËΩÆ: ÂèëÁé∞ÊúÄ‰Ω≥Ê®°Âûã! Â•ñÂä±: ${bestReward.toFixed(1)}`, 'success');
                        }

                        const avgReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                        this.updateStatus(
                            `üî• ËÆ≠ÁªÉ‰∏≠: ${episode + 1}/${nEpisodes} | ` +
                            `ÁõÆÊ†á:${episodeTarget.toFixed(1)}¬∞C | ` +
                            `Âô™Â£∞: ${(this.ddpgAgent.noiseScale * 100).toFixed(1)}% | ` +
                            `Â•ñÂä±: ${totalReward.toFixed(1)} | ` +
                            `Âπ≥Âùá: ${avgReward.toFixed(1)}`
                        );

                        // ËÆ°ÁÆóÊ∏©Â∫¶ËØØÂ∑ÆÊåáÊ†á
                        const avgError = tempErrors.reduce((a, b) => a + b, 0) / tempErrors.length;
                        const maxError = Math.max(...tempErrors);

                        this.log(
                            `üìà Á¨¨${episode + 1}ËΩÆ: Â•ñÂä±=${totalReward.toFixed(1)}, ` +
                            `ÁõÆÊ†áÊ∏©Â∫¶=${episodeTarget.toFixed(1)}¬∞C, ` +
                            `Âô™Â£∞=${(this.ddpgAgent.noiseScale * 100).toFixed(1)}%, ` +
                            `Âπ≥ÂùáËØØÂ∑Æ=${avgError.toFixed(2)}¬∞C, ` +
                            `Âà∞ËææÁõÆÊ†áÁî®Êó∂=${stepsToTarget !== null ? stepsToTarget : 'Êú™Ëææ'}Ê≠•`
                        );

                        // ÊØè 5 ËΩÆÊàñÊúÄÂêé‰∏ÄËΩÆÔºåÂø´ÈÄüËØÑ‰º∞‰∏ÄÊ¨°ÂçáÊ∏©Êõ≤Á∫ø
                        if (episode % 5 === 0 || episode === nEpisodes - 1) {
                            // ÂøÖÈ°ªÁî®Êú¨ËΩÆÁöÑ episodeTarget ‰º†ÂÖ• evaluateTrainingCurve
                            const evalResults = await this.evaluateTrainingCurve(this.ddpgAgent, config, episodeTarget, 600);

                            // Â¶ÇÊûúÊòØÊúÄÂêé‰∏ÄËΩÆÔºåÊòæÁ§∫ËØ¶ÁªÜÁöÑËØÑ‰º∞ÁªìÊûú
                            if (episode === nEpisodes - 1) {
                                this.log(
                                    `üìä ÊúÄÁªàÊ®°ÂûãËØÑ‰º∞: ` +
                                    `Âπ≥ÂùáÊ∏©Â∫¶ËØØÂ∑Æ=${evalResults.avgError.toFixed(2)}¬∞C, ` +
                                    `ÊúÄÂ§ßËØØÂ∑Æ=${evalResults.maxError.toFixed(2)}¬∞C, ` +
                                    `ÊúÄÁªàËØØÂ∑Æ=${evalResults.finalError.toFixed(2)}¬∞C, ` +
                                    `Áî®Êó∂=${evalResults.stepCount}Ê≠•`,
                                    'success'
                                );
                            }
                        }

                        await tf.nextFrame();
                    }

                    if (bestActorWeights && bestCriticWeights) {
                        await this.ddpgAgent.actor.setWeights(bestActorWeights);
                        await this.ddpgAgent.critic.setWeights(bestCriticWeights);
                        this.log(`üèÜ Â∑≤Âä†ËΩΩÊúÄ‰Ω≥Ê®°Âûã (Â•ñÂä±: ${bestReward.toFixed(1)})`, 'success');
                    }

                    this.updateStatus(`‚úÖ ${algorithm.toUpperCase()} ËÆ≠ÁªÉÂÆåÊàêÔºÅÂèØ‰ª•ÂºÄÂßãÊµãËØïÊéßÊ∏©ÊïàÊûú`);
                    this.log('üéâ ËÆ≠ÁªÉÂÆåÊàêÔºÅÊô∫ËÉΩ‰ΩìÂ∑≤ÂáÜÂ§áÂ∞±Áª™ÔºåÂèØËøõË°åÊéßÊ∏©ÊµãËØï', 'success');

                    /* === ËÆ≠ÁªÉÁªìÊùü: ÊÅ¢Â§çÂéÜÂè≤ÊúÄ‰Ω≥Âø´ÁÖß === */
                    if (bestActorWeights) {
                        const actorSnap = bestActorWeights.map(t => t.clone());   // clone Èò≤Ê≠¢‰øÆÊîπÂ§á‰ªΩ
                        this.ddpgAgent.actor.setWeights(actorSnap);
                        this.ddpgAgent.targetActor.setWeights(actorSnap);
                    }
                    if (bestCriticWeights) {
                        const criticSnap = bestCriticWeights.map(t => t.clone());
                        this.ddpgAgent.critic.setWeights(criticSnap);
                        this.ddpgAgent.targetCritic.setWeights(criticSnap);
                    }
                    // ËÆ≠ÁªÉÂÆåÊàêÂêéËØÑ‰º∞‰∏ÄÊ¨°ÂçáÊ∏©Êõ≤Á∫øÔºàÁî®Êé•Ëøë‰∏≠Èó¥ÂÄºÁöÑÁõÆÊ†áÊ∏©Â∫¶Ôºâ
                    const finalTarget = (config.targetMin + config.targetMax) / 2;
                    await this.evaluateTrainingCurve(this.ddpgAgent, config, finalTarget, 600);

                } catch (error) {
                    this.updateStatus('‚ùå ËÆ≠ÁªÉÂá∫Èîô: ' + error.message);
                    this.log('üí• ËÆ≠ÁªÉÈîôËØØ: ' + error.message, 'error');
                    console.error('Training error:', error);
                } finally {
                    this.isTraining = false;
                }
            }

            stopTraining() {
                this.isTraining = false;
                this.updateStatus('‚èπÔ∏è Ê≠£Âú®ÂÅúÊ≠¢ËÆ≠ÁªÉ...');
            }

            async testModel() {
                if (!this.ddpgAgent) {
                    this.log('‚ùå Ê≤°ÊúâÂèØÁî®ÁöÑËÆ≠ÁªÉÊ®°ÂûãÔºåËØ∑ÂÖàËøõË°åËÆ≠ÁªÉ', 'error');
                    return;
                }

                if (this.testSimulating) {
                    this.log('‚ö†Ô∏è ÊéßÊ∏©ÊµãËØïÂ∑≤Âú®ËøêË°å‰∏≠', 'warning');
                    return;
                }

                this.testSimulating = true;
                document.getElementById('stopTest').style.display = 'inline-block';
                this.updateStatus('üß™ Êô∫ËÉΩÊéßÊ∏©ÊµãËØï‰∏≠...');
                this.log('üöÄ ÂºÄÂßãÊô∫ËÉΩÊéßÊ∏©ÊµãËØï...');

                // === Â¢ûÂä†Á®≥ÊÄÅËÄÉÂØüÂèòÈáè ===
                let inTargetZone = false;
                let stableCount = 0;
                const stabilizationSteps = 500; // Á®≥ÊÄÅËÄÉÂØüÊ≠•Êï∞

                try {
                    const config = {
                        targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),
                        initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                        roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                        hA: parseFloat(document.getElementById('hAInput').value),
                        waterMass: parseFloat(document.getElementById('waterMassInput').value),
                        deltaT: parseFloat(document.getElementById('deltaT').value)
                    };

                    let lastPower = 0;
                    let waterTemp = config.initTemp;
                    let lastWaterTemp = waterTemp;
                    let dTdt = 0;
                    let step = 0;
                    const tempTrace = [];
                    const powerTrace = [];
                    const setTrace = [];
                    const tolerance = 0.05;

                    let state = [
                        waterTemp - config.targetTemp,
                        dTdt,
                        lastPower / this.ddpgAgent.maxPower
                    ];


                    const tempErrors = [];

                    while (this.testSimulating && step < 1000) {
                        // ‰º†ÂÖ•ÂΩìÂâçÊ∞¥Ê∏©ÂíåÁõÆÊ†áÊ∏©Â∫¶Ôºå‰ΩøÁî®Áõ∏ÂØπÊ∏©Â∫¶Âõ†Â≠ê
                        const heatingPower = await this.ddpgAgent.selectAction(state, waterTemp, config.targetTemp, false);
                        const deltaT = (heatingPower - config.hA * (waterTemp - config.roomTemp)) / (config.waterMass * 4184);
                        const nextWaterTemp = waterTemp + deltaT;
                        const nextDTdt = (nextWaterTemp - waterTemp) / config.deltaT;

                        tempTrace.push(nextWaterTemp);
                        powerTrace.push(heatingPower);
                        setTrace.push(config.targetTemp);

                        // Êî∂ÈõÜËØØÂ∑ÆÊï∞ÊçÆ
                        const tempError = Math.abs(nextWaterTemp - config.targetTemp);
                        tempErrors.push(tempError);

                        if (this.testCurveChart) {
                            this.testCurveChart.data.labels = tempTrace.map((_, i) => i);
                            this.testCurveChart.data.datasets[0].data = setTrace;
                            this.testCurveChart.data.datasets[1].data = tempTrace;
                            this.testCurveChart.data.datasets[2].data = powerTrace;
                            this.testCurveChart.update('none');
                        }

                        state = [
                            nextWaterTemp - config.targetTemp,
                            nextDTdt,
                            heatingPower / this.ddpgAgent.maxPower
                        ];

                        const reward = this.ddpgAgent.calculateReward(nextWaterTemp, config.targetTemp, heatingPower, lastWaterTemp, step);
                        lastPower = heatingPower;
                        lastWaterTemp = waterTemp;
                        waterTemp = nextWaterTemp;

                        this.updateMetrics(waterTemp, tempError, heatingPower, reward);
                        this.updateStatus(
                            `üå°Ô∏è ÊéßÊ∏©‰∏≠: ÂΩìÂâç${waterTemp.toFixed(1)}¬∞C | ` +
                            `ÁõÆÊ†á${config.targetTemp}¬∞C | ` +
                            `ËØØÂ∑Æ${tempError.toFixed(2)}¬∞C | ` +
                            `ÂäüÁéá${heatingPower.toFixed(0)}W`
                        );

                        if (Math.abs(waterTemp) > 200) {
                            this.log('‚ö†Ô∏è Ê£ÄÊµãÂà∞Ê∏©Â∫¶ÂºÇÂ∏∏ÔºåÈáçÁΩÆÁéØÂ¢É', 'warning');
                            waterTemp = config.initTemp;
                            lastWaterTemp = waterTemp;
                            dTdt = 0;
                            lastPower = 0;
                            state = [
                                waterTemp - config.targetTemp,
                                dTdt,
                                lastPower / this.ddpgAgent.maxPower
                            ];
                        }

                        step++;

                        // Êñ∞ÁöÑÊèêÂâçÁªàÊ≠¢ÈÄªËæëÔºöËøõÂÖ•ÁõÆÊ†áÂå∫Èó¥ÂêéËÄÉÂØüstabilizationStepsÊ≠•
                        if (!inTargetZone && tempError < tolerance) {
                            inTargetZone = true;
                            stableCount = 0;
                            this.log('üåà Â∑≤ËøõÂÖ•ÁõÆÊ†áÂå∫Èó¥ÔºåÂºÄÂßãÁ®≥ÊÄÅÊÄßËÉΩËÄÉÂØü...', 'success');
                        }

                        if (inTargetZone) {
                            stableCount++;
                            if (stableCount >= stabilizationSteps) {
                                this.log(`üéØ Á®≥ÊÄÅËÄÉÂØüÂÆåÊàêÔºåÊÄªÊ≠•Êï∞Ôºö${step}, ÊµãËØïÁªàÊ≠¢`, 'success');

                                // ËÆ°ÁÆóÁ®≥ÊÄÅÈò∂ÊÆµÁöÑÊÄßËÉΩÊåáÊ†á
                                const stableErrors = tempErrors.slice(-stabilizationSteps);
                                const avgStableError = stableErrors.reduce((sum, val) => sum + val, 0) / stableErrors.length;
                                const maxStableError = Math.max(...stableErrors);

                                this.log(
                                    `üìä Á®≥ÊÄÅÊéßÂà∂ÊÄßËÉΩ: ` +
                                    `Âπ≥ÂùáËØØÂ∑Æ=${avgStableError.toFixed(3)}¬∞C, ` +
                                    `ÊúÄÂ§ßËØØÂ∑Æ=${maxStableError.toFixed(3)}¬∞C`,
                                    'success'
                                );

                                break;
                            }
                        }

                        const simSpeed = parseFloat(document.getElementById('simSpeed').value);
                        if (simSpeed > 0) {
                            await new Promise(resolve => setTimeout(resolve, simSpeed * 1000));
                        } else {
                            await tf.nextFrame();
                        }
                    }

                } catch (error) {
                    this.updateStatus('‚ùå ÊµãËØïÂá∫Èîô: ' + error.message);
                    this.log('üí• ÊµãËØïÈîôËØØ: ' + error.message, 'error');
                    console.error('Test error:', error);
                } finally {
                    this.testSimulating = false;
                    document.getElementById('stopTest').style.display = 'none';
                    this.updateStatus('‚èπÔ∏è ÊéßÊ∏©ÊµãËØïÂ∑≤ÂÅúÊ≠¢');
                    this.log('üèÅ ÊéßÊ∏©ÊµãËØïÁªìÊùü');
                }
            }

            stopTestModel() {
                this.testSimulating = false;
                document.getElementById('stopTest').style.display = 'none';
                this.updateStatus('‚èπÔ∏è Ê≠£Âú®ÂÅúÊ≠¢ÊµãËØï...');
            }

            async saveModel() {
                if (!this.ddpgAgent?.actor || !this.ddpgAgent?.critic) {
                    this.log('‚ùå Ê≤°ÊúâÂèØ‰øùÂ≠òÁöÑÊ®°Âûã', 'error');
                    return;
                }

                try {
                    await this.ddpgAgent.actor.save('downloads://ddpg-actor-model');
                    await this.ddpgAgent.critic.save('downloads://ddpg-critic-model');
                    this.log('üíæ ActorÂíåCriticÊ®°Âûã‰øùÂ≠òÊàêÂäü', 'success');
                    this.updateStatus('‚úÖ Ê®°ÂûãÂ∑≤‰øùÂ≠òÂà∞‰∏ãËΩΩÊñá‰ª∂Â§π');
                } catch (error) {
                    this.log('‚ùå Ê®°Âûã‰øùÂ≠òÂ§±Ë¥•: ' + error.message, 'error');
                    this.updateStatus('‚ùå ‰øùÂ≠òÂ§±Ë¥•');
                }
            }

            async loadModel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.multiple = true;

                input.onchange = async (event) => {
                    try {
                        const files = Array.from(event.target.files);

                        // ÈúÄË¶ÅÂä†ËΩΩActorÂíåCritic‰∏§‰∏™Ê®°Âûã
                        this.log('üìÅ ËØ∑ÈÄâÊã©ActorÊ®°ÂûãÊñá‰ª∂...');
                        const actorModel = await tf.loadLayersModel(tf.io.browserFiles(files));

                        this.log('üìÅ ËØ∑ÂÜçÊ¨°ÈÄâÊã©CriticÊ®°ÂûãÊñá‰ª∂...');
                        const input2 = document.createElement('input');
                        input2.type = 'file';
                        input2.accept = '.json';
                        input2.multiple = true;

                        input2.onchange = async (event2) => {
                            try {
                                const files2 = Array.from(event2.target.files);
                                const criticModel = await tf.loadLayersModel(tf.io.browserFiles(files2));

                                const config = {
                                    maxPower: parseFloat(document.getElementById('maxPowerInput').value),
                                    targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),
                                    initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                                    roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                                    hA: parseFloat(document.getElementById('hAInput').value),
                                    waterMass: parseFloat(document.getElementById('waterMassInput').value)
                                };

                                this.ddpgAgent = new DDPGAgent(config);
                                this.ddpgAgent.actor = actorModel;
                                this.ddpgAgent.critic = criticModel;
                                this.ddpgAgent.updateTargetNetworks(1.0);

                                this.log('üìÅ ActorÂíåCriticÊ®°ÂûãÂä†ËΩΩÊàêÂäü', 'success');
                                this.updateStatus('‚úÖ Ê®°ÂûãÂ∑≤Âä†ËΩΩÔºåÂèØ‰ª•ÂºÄÂßãÊµãËØï');

                                // Âä†ËΩΩÊ®°ÂûãÂêéËøõË°å‰∏ÄÊ¨°ËØÑ‰º∞
                                const evalTarget = config.targetTemp;
                                await this.evaluateTrainingCurve(this.ddpgAgent, config, evalTarget, 600);

                            } catch (innerError) {
                                this.log('‚ùå CriticÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•: ' + innerError.message, 'error');
                            }
                        };

                        input2.click();

                    } catch (error) {
                        this.log('‚ùå ActorÊ®°ÂûãÂä†ËΩΩÂ§±Ë¥•: ' + error.message, 'error');
                        this.updateStatus('‚ùå Âä†ËΩΩÂ§±Ë¥•');
                    }
                };

                input.click();
            }
        }
    </script>
</body>

</html>