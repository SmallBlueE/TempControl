<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DDPGå¼ºåŒ–å­¦ä¹ æ§æ¸©ç³»ç»Ÿ</title>
    <!-- 2025-06-12 æ›´æ–°: è®­ç»ƒè½¨è¿¹ä¼˜åŒ–ç‰ˆæœ¬ -->
    <!-- ä½¿ç”¨å¤šä¸ªCDNå¤‡é€‰æ–¹æ¡ˆ -->
    <script>
        // åŠ¨æ€åŠ è½½TensorFlow.js
        function loadScript(src, fallbacks = []) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = () => {
                    if (fallbacks.length > 0) {
                        loadScript(fallbacks.shift(), fallbacks).then(resolve).catch(reject);
                    } else {
                        reject(new Error(`Failed to load script: ${src}`));
                    }
                };
                document.head.appendChild(script);
            });
        }

        // åŠ è½½å¿…è¦çš„åº“
        Promise.all([
            loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js', [
                'https://unpkg.com/@tensorflow/tfjs@latest/dist/tf.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js'
            ]),
            loadScript('https://cdn.jsdelivr.net/npm/chart.js', [
                'https://unpkg.com/chart.js',
                'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js'
            ])
        ]).then(() => {
            // å¼ºåˆ¶åˆ‡æ¢åç«¯å¹¶ç­‰åˆ° ready åå†åˆå§‹åŒ–
            tf.setBackend('cpu').then(() => {
                tf.ready().then(() => {
                    console.log('å·²åˆ‡æ¢åˆ° CPU backend');
                    window.librariesLoaded = true;
                    if (window.initializeApp) window.initializeApp();
                });
            });
        }).catch(error => {
            console.error('åº“åŠ è½½å¤±è´¥:', error);
            document.body.innerHTML = `
                <div style="padding: 20px; text-align: center; color: red;">
                    <h2>âš ï¸ ç½‘ç»œåº“åŠ è½½å¤±è´¥</h2>
                    <p>è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ä½¿ç”¨ç¦»çº¿ç‰ˆæœ¬</p>
                    <p>é”™è¯¯ä¿¡æ¯: ${error.message}</p>
                    <button onclick="location.reload()">é‡æ–°åŠ è½½</button>
                </div>
            `;
        });
    </script>
    <style>
        /* ä¿ç•™åŸæœ‰CSSæ ·å¼ */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 10px;
            color: white;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #e9ecef;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 14px;
        }

        .control-group input,
        .control-group select {
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }

        .buttons {
            display: flex;
            gap: 15px;
            margin: 30px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .btn:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .btn:hover:before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #007bff, #0056b3);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #28a745, #218838);
            color: white;
        }

        .btn-info {
            background: linear-gradient(45deg, #17a2b8, #138496);
            color: white;
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: 600;
            background: linear-gradient(45deg, #e9ecef, #f8f9fa);
            border-left: 5px solid #007bff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .charts {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin: 30px 0;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .chart-container h3 {
            margin: 0 0 15px 0;
            color: #495057;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        .log-container {
            height: 250px;
            overflow-y: auto;
            border: 2px solid #dee2e6;
            padding: 15px;
            background: #f8f9fa;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border-radius: 8px;
            line-height: 1.4;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            font-size: 18px;
            color: #6c757d;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-right: 15px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #stopTest {
            display: none;
        }

        .metric-card {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin: 10px 0;
        }

        .metric-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 12px;
            opacity: 0.9;
        }

        /* æ–°å¢: è¿›åº¦æŒ‡ç¤ºå™¨æ ·å¼ */
        .progress-container {
            margin: 15px 0;
            background-color: #f0f0f0;
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
            transition: width 0.5s;
            position: relative;
        }

        /* æ–°å¢: è®­ç»ƒæŒ‡æ ‡å¡ç‰‡ */
        .training-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .metric-mini-card {
            background: linear-gradient(45deg, #4b6cb7, #182848);
            padding: 10px;
            border-radius: 8px;
            color: white;
            text-align: center;
        }

        .metric-mini-value {
            font-size: 18px;
            font-weight: bold;
        }

        .metric-mini-label {
            font-size: 11px;
            opacity: 0.9;
        }
    </style>
</head>

<body>
    <!-- ä¿ç•™åŸæœ‰HTMLç»“æ„ -->
    <div class="container">
        <div class="header">
            <h1>ğŸ¤– DDPGå¼ºåŒ–å­¦ä¹ æ™ºèƒ½æ§æ¸©ç³»ç»Ÿ</h1>
            <p>åŸºäºæ·±åº¦ç¡®å®šæ€§ç­–ç•¥æ¢¯åº¦çš„è¿ç»­æ§åˆ¶</p>
        </div>

        <div id="loadingIndicator" class="loading">
            <div class="spinner"></div>
            æ­£åœ¨åŠ è½½ç³»ç»Ÿç»„ä»¶...
        </div>

        <div id="mainContent" style="display: none;">
            <!-- æ§åˆ¶å‚æ•° -->
            <div class="controls">
                <div class="control-group">
                    <label for="targetWaterTemp">ğŸ¯ æµ‹è¯•é˜¶æ®µç›®æ ‡æ°´æ¸© (Â°C)</label>
                    <input type="number" id="targetWaterTemp" value="45" min="20" max="100" step="0.1">
                </div>
                <div class="control-group">
                    <label for="initWaterTemp">ğŸŒ¡ï¸ åˆå§‹æ°´æ¸© (Â°C)</label>
                    <input type="number" id="initWaterTemp" value="25" min="10" max="50" step="0.1">
                </div>
                <div class="control-group">
                    <label for="roomTempInput">ğŸ  ç¯å¢ƒæ¸©åº¦ (Â°C)</label>
                    <input type="number" id="roomTempInput" value="22" min="10" max="40" step="0.1">
                </div>
                <div class="control-group">
                    <label for="maxPowerInput">âš¡ æœ€å¤§åŠŸç‡ (W)</label>
                    <input type="number" id="maxPowerInput" value="3000" min="500" max="5000" step="100">
                </div>
                <div class="control-group">
                    <label for="hAInput">ğŸ”„ ä¼ çƒ­ç³»æ•°</label>
                    <input type="number" id="hAInput" value="60" min="20" max="100" step="1">
                </div>
                <div class="control-group">
                    <label for="waterMassInput">ğŸ’§ æ°´è´¨é‡ (kg)</label>
                    <input type="number" id="waterMassInput" value="1.0" min="0.1" max="5.0" step="0.1">
                </div>
                <div class="control-group">
                    <label for="epochs">ğŸ”„ è®­ç»ƒè½®æ•°</label>
                    <input type="number" id="epochs" value="200" min="50" max="1000" step="10">
                </div>
                <div class="control-group">
                    <label for="modelComplexity">ğŸ§  æ¨¡å‹å¤æ‚åº¦</label>
                    <select id="modelComplexity">
                        <option value="1">æç®€ (1å±‚)</option>
                        <option value="2">å¾ˆç®€ (2å±‚)</option>
                        <option value="3" selected>ç®€å• (3å±‚)</option>
                        <option value="4">ä¸­ç­‰ (4å±‚)</option>
                        <option value="5">å¤æ‚ (5å±‚)</option>
                        <option value="6">å¾ˆå¤æ‚ (6å±‚)</option>
                        <option value="7">è¶…å¤æ‚ (7å±‚)</option>
                        <option value="8">æè‡´ (8å±‚)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="algorithmSelect">ğŸ§® ç®—æ³•</label>
                    <select id="algorithmSelect">
                        <option value="ddpg" selected>DDPG</option>
                        <option value="td3">TD3</option>
                        <option value="sac">SAC</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="simSpeed">â±ï¸ ä»¿çœŸé€Ÿåº¦ (ç§’)</label>
                    <input type="number" id="simSpeed" value="0.01" min="0" max="2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="deltaT">ğŸ”§ ä»¿çœŸæ­¥é•¿ Î”t (s)</label>
                    <input type="number" id="deltaT" value="1" min="1" max="5" step="0.1">
                </div>
            </div>

            <!-- æ§åˆ¶æŒ‰é’® -->
            <div class="buttons">
                <button id="startTraining" class="btn btn-primary">ğŸš€ å¼€å§‹è®­ç»ƒ</button>
                <button id="stopTraining" class="btn btn-danger">â¹ï¸ åœæ­¢è®­ç»ƒ</button>
                <button id="testModel" class="btn btn-success">ğŸ§ª æµ‹è¯•æ§æ¸©</button>
                <button id="stopTest" class="btn btn-danger">â¹ï¸ åœæ­¢æµ‹è¯•</button>
                <button id="saveModel" class="btn btn-info">ğŸ’¾ ä¿å­˜æ¨¡å‹</button>
                <button id="loadModel" class="btn btn-info">ğŸ“ åŠ è½½æ¨¡å‹</button>
            </div>

            <!-- çŠ¶æ€æ˜¾ç¤º -->
            <div id="status" class="status">ğŸŸ¢ ç³»ç»Ÿå°±ç»ªï¼Œå¯ä»¥å¼€å§‹è®­ç»ƒ</div>

            <!-- è®­ç»ƒè¿›åº¦æ¡ (æ–°å¢) -->
            <div id="trainingProgress" style="display: none;">
                <p><strong>è®­ç»ƒè¿›åº¦:</strong> <span id="progressText">0%</span></p>
                <div class="progress-container">
                    <div class="progress-bar" id="progressBar" style="width: 0%"></div>
                </div>

                <!-- è®­ç»ƒæŒ‡æ ‡ (æ–°å¢) -->
                <div class="training-metrics" id="trainingMetricsPanel">
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="currentEpisode">--</div>
                        <div class="metric-mini-label">å½“å‰è½®æ¬¡</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="avgReward">--</div>
                        <div class="metric-mini-label">å¹³å‡å¥–åŠ±</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="currentNoise">--</div>
                        <div class="metric-mini-label">æ¢ç´¢å™ªå£°</div>
                    </div>
                    <div class="metric-mini-card">
                        <div class="metric-mini-value" id="avgError">--</div>
                        <div class="metric-mini-label">å¹³å‡è¯¯å·®(Â°C)</div>
                    </div>
                </div>
            </div>

            <!-- å®æ—¶æŒ‡æ ‡ -->
            <div id="metricsPanel" style="display: none;">
                <div
                    style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0;">
                    <div class="metric-card">
                        <div class="metric-value" id="currentTemp">--</div>
                        <div class="metric-label">å½“å‰æ¸©åº¦ (Â°C)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentError">--</div>
                        <div class="metric-label">æ¸©åº¦è¯¯å·® (Â°C)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentPower">--</div>
                        <div class="metric-label">å½“å‰åŠŸç‡ (W)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="currentReward">--</div>
                        <div class="metric-label">å½“å‰å¥–åŠ±</div>
                    </div>
                </div>
            </div>

            <!-- å›¾è¡¨æ˜¾ç¤º -->
            <div class="charts">
                <div class="chart-container">
                    <h3>ğŸ“ˆ è®­ç»ƒå¥–åŠ±æ›²çº¿</h3>
                    <canvas id="lossChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <h3>ğŸ“‰ Actor/CriticæŸå¤±æ›²çº¿</h3>
                    <canvas id="tdLossChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container">
                    <h3>ğŸ”¥ è®­ç»ƒä¸­æ°´æ¸©è½¨è¿¹</h3>
                    <canvas id="trainCurveChart" width="400" height="200"></canvas>
                </div>
                <div class="chart-container full-width">
                    <h3>ğŸŒ¡ï¸ æ§æ¸©è¿‡ç¨‹æ›²çº¿</h3>
                    <canvas id="testCurveChart" width="800" height="300"></canvas>
                </div>
                <!-- æ–°å¢å›¾è¡¨: æ¸©åº¦è¯¯å·®æ›²çº¿ -->
                <div class="chart-container full-width">
                    <h3>ğŸ“Š è®­ç»ƒè¿‡ç¨‹æ¸©åº¦è¯¯å·®å˜åŒ–</h3>
                    <canvas id="errorChart" width="800" height="300"></canvas>
                </div>
            </div>

            <!-- æ—¥å¿—æ˜¾ç¤º -->
            <div class="chart-container">
                <h3>ğŸ“‹ ç³»ç»Ÿæ—¥å¿—</h3>
                <div id="logContainer" class="log-container"></div>
            </div>
        </div>
    </div>

    <script>
        // ç­‰å¾…åº“åŠ è½½å®Œæˆååˆå§‹åŒ–åº”ç”¨
        window.initializeApp = function () {
            document.getElementById('loadingIndicator').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';

            // æ£€æŸ¥TensorFlow.jsæ˜¯å¦å¯ç”¨
            if (typeof tf === 'undefined') {
                document.getElementById('status').innerHTML = 'âŒ TensorFlow.js åŠ è½½å¤±è´¥';
                return;
            }
            // æ£€æŸ¥ TensorFlow.js backend æ˜¯å¦å¯ç”¨
            if (!tf || !tf.engine().backend) {
                document.getElementById('status').innerHTML = 'âŒ TensorFlow.js backend æœªå°±ç»ªï¼Œè¯·åˆ·æ–°é‡è¯•';
                return;
            }

            // æ£€æŸ¥Chart.jsæ˜¯å¦å¯ç”¨
            if (typeof Chart === 'undefined') {
                document.getElementById('status').innerHTML = 'âŒ Chart.js åŠ è½½å¤±è´¥';
                return;
            }

            // åˆå§‹åŒ–æ§åˆ¶å™¨
            window.controller = new MLController();
            console.log('ğŸš€ DDPGæ™ºèƒ½æ§æ¸©ç³»ç»Ÿå·²å¯åŠ¨');
        };

        // å¦‚æœåº“å·²ç»åŠ è½½å®Œæˆ
        if (window.librariesLoaded) {
            window.initializeApp();
        }

        // =========== ä¼˜å…ˆç»éªŒå›æ”¾ç¼“å†²åŒº ===============
        class PrioritizedReplayBuffer {
            constructor(capacity, alpha = 0.6) {
                this.capacity = capacity;
                this.buffer = [];
                this.priorities = [];
                this.alpha = alpha;
                this.beta = 0.4;
                this.betaIncrement = 0.001;
                this.maxBeta = 1.0;
                this.epsilon = 1e-6;
            }

            add(experience, tdError = 1.0) {
                const priority = Math.pow(Math.abs(tdError) + this.epsilon, this.alpha);

                if (this.buffer.length < this.capacity) {
                    this.buffer.push(experience);
                    this.priorities.push(priority);
                } else {
                    const idx = Math.floor(Math.random() * this.capacity);
                    this.buffer[idx] = experience;
                    this.priorities[idx] = priority;
                }
            }

            sample(batchSize) {
                const indices = [];
                const experiences = [];
                const weights = [];

                if (this.buffer.length === 0) {
                    return { indices: [], experiences: [], weights: [] };
                }

                const totalPriority = this.priorities.reduce((sum, p) => sum + p, 0);

                // ä¿æŠ¤: ç¡®ä¿æœ‰è¶³å¤Ÿæ•°æ®å¯ä»¥é‡‡æ ·
                const actualBatchSize = Math.min(batchSize, this.buffer.length);

                for (let i = 0; i < actualBatchSize; i++) {
                    const rand = Math.random() * totalPriority;
                    let cumSum = 0;
                    let idx = 0;

                    for (let j = 0; j < this.priorities.length; j++) {
                        cumSum += this.priorities[j];
                        if (cumSum >= rand) {
                            idx = j;
                            break;
                        }
                    }

                    indices.push(idx);
                    experiences.push(this.buffer[idx]);

                    const prob = this.priorities[idx] / totalPriority;
                    const weight = Math.pow(prob * this.buffer.length, -this.beta);
                    weights.push(weight);
                }

                const maxWeight = Math.max(...weights, 0.00001); // é˜²æ­¢é™¤é›¶é”™è¯¯
                const normalizedWeights = weights.map(w => w / maxWeight);

                this.beta = Math.min(this.maxBeta, this.beta + this.betaIncrement);

                return { indices, experiences, weights: normalizedWeights };
            }

            updatePriorities(indices, tdErrors) {
                for (let i = 0; i < indices.length; i++) {
                    if (indices[i] >= 0 && indices[i] < this.priorities.length) {
                        const priority = Math.pow(Math.abs(tdErrors[i]) + this.epsilon, this.alpha);
                        this.priorities[indices[i]] = priority;
                    }
                }
            }

            size() {
                return this.buffer.length;
            }

            // æ–°å¢: æ¸…é™¤ä¸€éƒ¨åˆ†æ—§ç»éªŒï¼Œä¿æŒç»éªŒå¤šæ ·æ€§
            clearOldExperiences(percentage = 0.1) {
                if (this.buffer.length < 1000) return; // åªåœ¨ç¼“å†²åŒºè¾ƒå¤§æ—¶æ‰§è¡Œ

                const numToRemove = Math.floor(this.buffer.length * percentage);
                const indices = [];

                // ç”Ÿæˆè¦ç§»é™¤çš„éšæœºç´¢å¼•
                for (let i = 0; i < numToRemove; i++) {
                    const idx = Math.floor(Math.random() * this.buffer.length);
                    indices.push(idx);
                }

                // å¯¹ç´¢å¼•æ’åºå¹¶ä»åå‘å‰ç§»é™¤
                indices.sort((a, b) => b - a);
                for (const idx of indices) {
                    this.buffer.splice(idx, 1);
                    this.priorities.splice(idx, 1);
                }
            }
        }

        // =========== Ornstein-Uhlenbeckå™ªå£° ===============
        class OUNoise {
            constructor(size, mu = 0, theta = 0.15, sigma = 0.2) {
                this.size = size;
                this.mu = mu;
                this.theta = theta;
                this.sigma = sigma;
                this.state = tf.zeros([size]);
                this.reset();
            }

            reset() {
                this.state = tf.zeros([this.size]);
            }

            sample() {
                const x = this.state;
                const dx = tf.add(
                    tf.mul(this.theta, tf.sub(this.mu, x)),
                    tf.mul(this.sigma, tf.randomNormal([this.size]))
                );
                this.state = tf.add(x, dx);
                return this.state;
            }
        }

        // ============= ä¿®æ”¹åçš„DDPG Agent ==================
        class DDPGAgent {
            constructor(config) {
                this.config = config;
                this.maxPower = config.maxPower;
                this.roomTemp = config.roomTemp; // ä¿å­˜å®¤æ¸©ä¾›è®¡ç®—ç›¸å¯¹æ¸©åº¦

                // DDPGè¶…å‚æ•°ä¼˜åŒ–
                this.gamma = 0.99;          // ç¨å¾®é™ä½ä»¥å‡å°‘é•¿æœŸä¸ç¡®å®šæ€§
                this.tau = 0.005;           // é™ä½ç›®æ ‡ç½‘ç»œæ›´æ–°é€Ÿç‡ï¼Œå¢åŠ ç¨³å®šæ€§
                this.batchSize = 64;       // å¢å¤§æ‰¹æ¬¡å¤§å°
                this.actorLr = 0.0001;      // é™ä½å­¦ä¹ ç‡
                this.criticLr = 0.001;      // ä¿æŒCriticå­¦ä¹ ç‡è¾ƒé«˜

                // æ„å»ºç½‘ç»œ
                this.buildNetworks();

                // æ”¹è¿›ç»éªŒå›æ”¾
                this.replayBuffer = new PrioritizedReplayBuffer(50000, 0.7); // æ›´å¤§çš„ç¼“å†²åŒº

                // æ”¹è¿›æ¢ç´¢ç­–ç•¥
                this.noise = new OUNoise(1, 0, 0.2, 0.6); // Î¼=0, Î¸=0.2, Ïƒ=0.6
                this.noiseScale = 1.0;       // å¢å¤§åˆå§‹æ¢ç´¢ç¨‹åº¦
                this.noiseDecay = 0.9995;    // é™ä½å™ªå£°è¡°å‡é€Ÿç‡
                this.minNoiseScale = 0.1;    // æé«˜æœ€å°å™ªå£°é™åˆ¶

                // æŸå¤±è®°å½•
                this.actorLoss = 0;
                this.criticLoss = 0;

                // è®­ç»ƒç¨³å®šæ€§è¿½è¸ª
                this.trainingStability = {
                    recentRewards: [],
                    bestReward: -Infinity,
                    noImprovementCount: 0
                };

                this.noiseAnnealingSteps = 300; // å™ªå£°è¡°å‡æ­¥æ•°å¢åŠ 
            }

            buildNetworks() {
                // æ ¹æ®ç”¨æˆ·é€‰æ‹©åŠ¨æ€è®¾ç½®ç½‘ç»œå±‚æ•°
                let numLayers = 3;
                const complexitySel = document.getElementById('modelComplexity');
                if (complexitySel) numLayers = parseInt(complexitySel.value) || 3;

                // ä½¿ç”¨æ›´å®½çš„ç½‘ç»œå±‚
                const layers = Array(numLayers).fill(96);

                // æ„å»ºActorç½‘ç»œ - å¢åŠ è¾“å…¥ç»´åº¦ï¼ŒåŒ…å«ç›¸å¯¹æ¸©åº¦
                this.actor = this.createActor(layers);
                this.targetActor = this.createActor(layers);

                // æ„å»ºCriticç½‘ç»œ
                this.critic = this.createCritic(layers);
                this.targetCritic = this.createCritic(layers);

                // åˆå§‹åŒ–ç›®æ ‡ç½‘ç»œ
                this.updateTargetNetworks(1.0);
            }

            createActor(layers) {
                const model = tf.sequential();
                // å¢åŠ è¾“å…¥ç»´åº¦ï¼ŒåŠ å…¥ç›¸å¯¹æ¸©åº¦å› å­
                model.add(tf.layers.dense({
                    inputShape: [4],
                    units: layers[0],
                    activation: 'relu',
                    kernelInitializer: tf.initializers.heNormal()
                }));

                // æ·»åŠ æ‰¹é‡å½’ä¸€åŒ–ä»¥æé«˜è®­ç»ƒç¨³å®šæ€§
                model.add(tf.layers.batchNormalization());

                for (let i = 1; i < layers.length; i++) {
                    model.add(tf.layers.dense({
                        units: layers[i],
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }));

                    if (i < layers.length - 1) {
                        model.add(tf.layers.batchNormalization());
                    }
                }

                model.add(tf.layers.dense({
                    units: 1,
                    activation: 'sigmoid',   // è¾“å‡ºç›´æ¥ 0-1
                    kernelInitializer: tf.initializers.glorotNormal()
                }));

                model.compile({
                    loss: tf.losses.meanSquaredError,
                    optimizer: tf.train.adam(this.actorLr)
                });

                return model;
            }

            createCritic(layers) {
                // çŠ¶æ€è¾“å…¥å¢åŠ ç›¸å¯¹æ¸©åº¦å› å­
                const stateInput = tf.input({ shape: [4] });
                const actionInput = tf.input({ shape: [1] });

                let stateH = tf.layers.dense({
                    units: layers[0],
                    activation: 'relu',
                    kernelInitializer: 'heNormal'
                }).apply(stateInput);

                // æ·»åŠ æ‰¹é‡å½’ä¸€åŒ–
                stateH = tf.layers.batchNormalization().apply(stateH);

                for (let i = 1; i < layers.length; i++) {
                    stateH = tf.layers.dense({
                        units: layers[i],
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }).apply(stateH);

                    if (i < layers.length - 1) {
                        stateH = tf.layers.batchNormalization().apply(stateH);
                    }
                }

                const concat = tf.layers.concatenate().apply([stateH, actionInput]);

                let qValue = tf.layers.dense({
                    units: 64,
                    activation: 'relu',
                    kernelInitializer: 'heNormal'
                }).apply(concat);

                qValue = tf.layers.dense({
                    units: 1,
                    activation: 'linear',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(qValue);

                const model = tf.model({
                    inputs: [stateInput, actionInput],
                    outputs: qValue
                });

                model.compile({
                    optimizer: tf.train.adam(this.criticLr),
                    loss: tf.losses.huberLoss // ä½¿ç”¨Huber Lossæé«˜ç¨³å®šæ€§
                });

                return model;
            }

            // æ”¹è¿›çŠ¶æ€å½’ä¸€åŒ–æ–¹æ³•
            normalizeState(state, waterTemp, targetTemp) {
                // state = [Î”T, lastWaterTemp, P_prev (0-1)]
                const [dT, lastT, pPrev] = state;

                // 1) Î”T å½’ä¸€åŒ– (span 5-25 Â°C)
                const span = Math.max(5, Math.min(25, targetTemp - this.roomTemp));
                const n_dT = Math.max(-1, Math.min(1, dT / span));

                // 2) ä¸Šä¸€æ¬¡æ°´æ¸©
                const n_Tprev = Math.max(-1, Math.min(1, (lastT - this.roomTemp) / 100));

                // 3) ä¸Šä¸€æ­¥åŠŸç‡
                const n_p = Math.max(0, Math.min(1, pPrev));

                // 4) ç»å¯¹æ°´æ¸©
                const n_absT = (waterTemp - this.roomTemp) / 100;

                return [n_dT, n_Tprev, n_p, n_absT];
            }

            // ä¿®æ”¹åŠ¨ä½œé€‰æ‹©æ–¹æ³•
            async selectAction(state, waterTemp, targetTemp, training = true) {
                const normalizedState = this.normalizeState(state, waterTemp, targetTemp);
                const stateTensor = tf.tensor2d([normalizedState]);

                let action = this.actor.predict(stateTensor);

                // å¢å¼ºæ¢ç´¢æœºåˆ¶
                if (training && this.noiseScale > this.minNoiseScale) {
                    const noise = this.noise.sample();
                    const scaledNoise = tf.mul(noise, this.noiseScale);
                    action = tf.add(action, scaledNoise);

                    // å¢åŠ æ¸©åº¦è¯¯å·®è¾ƒå¤§æ—¶çš„é¢å¤–æ¢ç´¢
                    const tempError = Math.abs(waterTemp - targetTemp);
                    if (tempError > 2.0) {
                        const extraNoise = tf.randomUniform([1], -0.2, 0.2);
                        action = tf.add(action, extraNoise);
                    }
                }

                // é™åˆ¶åœ¨ [0,1]
                action = tf.clipByValue(action, 0, 1);
                const actionArray = await action.array();
                tf.dispose([stateTensor, action]);

                // é¢å¤–: åœ¨å¿«æ¥è¿‘ç›®æ ‡æ¸©åº¦æ—¶æä¾›æ›´ç²¾ç»†çš„æ§åˆ¶
                const controlValue = actionArray[0][0] * this.maxPower;
                const tempError = Math.abs(waterTemp - targetTemp);
                if (!training && tempError < 1.0) {
                    // æ¥è¿‘ç›®æ ‡æ¸©åº¦æ—¶ï¼Œä½¿ç”¨æ›´ç²¾ç»†çš„æ§åˆ¶ç­–ç•¥
                    return this.preciseControlStrategy(controlValue, waterTemp, targetTemp);
                }

                return controlValue;
            }

            // æ–°å¢: ç²¾ç»†æ§æ¸©ç­–ç•¥
            preciseControlStrategy(initialPower, waterTemp, targetTemp) {
                const error = waterTemp - targetTemp;

                // å·²ç»åœ¨ç›®æ ‡æ¸©åº¦é™„è¿‘ï¼Œä½¿ç”¨PIæ§åˆ¶æ¨¡å¼
                if (Math.abs(error) < 0.3) {
                    // ç®€åŒ–çš„PIæ§åˆ¶å™¨
                    const kP = 300; // æ¯”ä¾‹ç³»æ•°
                    const power = initialPower - (error * kP);
                    return Math.max(0, Math.min(this.maxPower, power));
                }

                // è¿˜åœ¨æ¥è¿‘è¿‡ç¨‹ä¸­ï¼Œä½†å·²ç»å¾ˆæ¥è¿‘
                if (error < 0 && error > -1.0) {
                    // æ°´æ¸©ä½äºç›®æ ‡ã€ä½†å¾ˆæ¥è¿‘æ—¶ï¼Œé™ä½åŠŸç‡é¿å…è¿‡å†²
                    return initialPower * 0.85;
                }

                return initialPower; // å…¶ä»–æƒ…å†µä½¿ç”¨åŸå§‹æ§åˆ¶ç­–ç•¥
            }

            // ä¼˜åŒ–å¥–åŠ±å‡½æ•°ï¼Œä½¿å…¶æ›´å…·æœ‰æŒ‡å¯¼æ€§
            calculateReward(waterTemp, targetTemp, heatingPower, lastWaterTemp, stepCount) {
                const error = waterTemp - targetTemp;
                const prevError = lastWaterTemp - targetTemp;

                // 1. ç²¾ç¡®æ§æ¸©çŠ¶æ€ - é«˜å¥–åŠ±
                if (Math.abs(error) < 0.1) {
                    return 100;
                }

                // 2. åŸºç¡€å¥–åŠ±è®¡ç®—
                let reward = 0;

                // æ¸©å·®æ”¹è¿›å¥–åŠ± - æœ€é‡è¦çš„æŒ‡å¯¼ä¿¡å·
                const improvement = Math.abs(prevError) - Math.abs(error);
                reward += improvement * 100; // å¼ºåŒ–æ¸©å·®æ”¹è¿›çš„é‡è¦æ€§

                // æ¸©å·®æƒ©ç½š - ä½¿ç”¨å¯¹æ•°æ¯”ä¾‹ï¼Œå¯¹å¤§è¯¯å·®æ›´æ•æ„Ÿ
                reward -= Math.log(1 + Math.abs(error)) * 20;

                // è¿‡å†²æƒ©ç½š - æ›´ä¸¥æ ¼
                if (error > 0) {
                    reward -= Math.pow(error, 2) * 30;
                }

                // æ§æ¸©æ¥è¿‘ç›®æ ‡åŒºåŸŸæ—¶çš„é¢å¤–å¥–åŠ±
                if (Math.abs(error) < 1.0) {
                    reward += (1.0 - Math.abs(error)) * 20;
                }

                return reward;
            }

            remember(state, action, reward, nextState, done, waterTemp, targetTemp, nextWaterTemp) {
                // å­˜å‚¨æ‰©å±•çŠ¶æ€ï¼ˆåŒ…å«ç›¸å¯¹æ¸©åº¦å› å­ï¼‰
                const experience = [
                    this.normalizeState(state, waterTemp, targetTemp),
                    action / this.maxPower,  // å½’ä¸€åŒ–åŠ¨ä½œï¼ˆåŠŸç‡ç³»æ•°0~1ï¼‰
                    reward,
                    this.normalizeState(nextState, nextWaterTemp, targetTemp),
                    done
                ];
                this.replayBuffer.add(experience);
            }

            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { indices, experiences, weights } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // å®‰å…¨æ£€æŸ¥

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // è®­ç»ƒCritic
                    const nextActions = this.targetActor.predict(nextStates);
                    const nextQ = this.targetCritic.predict([nextStates, nextActions]);
                    const nextQFlat = tf.squeeze(nextQ);

                    const targetQ = tf.add(
                        rewards,
                        tf.mul(tf.mul(this.gamma, nextQFlat), dones)
                    );

                    const targetQExpanded = tf.expandDims(targetQ, 1);

                    // å¢åŠ æ¢¯åº¦è£å‰ªï¼Œæé«˜è®­ç»ƒç¨³å®šæ€§
                    const criticHistory = await this.critic.fit(
                        [states, actions],
                        targetQExpanded,
                        {
                            epochs: 1,
                            verbose: 0,
                            batchSize: this.batchSize
                        }
                    );

                    this.criticLoss = criticHistory.history.loss[0];

                    // è®­ç»ƒActor
                    await this.trainActor(states);

                    // æ›´æ–°TDè¯¯å·®ä»¥æ›´æ–°ä¼˜å…ˆçº§
                    const predictedQ = this.critic.predict([states, actions]);
                    const tdErrors = tf.sub(targetQExpanded, predictedQ).arraySync().map(e => e[0]);
                    this.replayBuffer.updatePriorities(indices, tdErrors);

                    // è½¯æ›´æ–°ç›®æ ‡ç½‘ç»œ
                    this.updateTargetNetworks(this.tau);

                    // è¡°å‡å™ªå£° - ä½¿ç”¨ä½™å¼¦è¡°å‡æ›²çº¿
                    if (this.noiseScale > this.minNoiseScale) {
                        const cosDecayRate = this.noiseDecay * (1 + Math.cos(Math.PI * this.trainingStability.noImprovementCount / 30) * 0.1);
                        this.noiseScale = Math.max(
                            this.minNoiseScale,
                            this.noiseScale * cosDecayRate
                        );
                    }

                    // æ¸…ç†å¼ é‡
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextActions, nextQ, nextQFlat, targetQ, targetQExpanded, predictedQ]);

                    // å‘¨æœŸæ€§åœ°æ¸…é™¤ä¸€å°éƒ¨åˆ†æ—§ç»éªŒï¼Œä¿æŒç»éªŒå¤šæ ·æ€§
                    if (Math.random() < 0.01) { // 1%æ¦‚ç‡è§¦å‘
                        this.replayBuffer.clearOldExperiences(0.05);
                    }

                } catch (error) {
                    console.error("è®­ç»ƒè¿‡ç¨‹ä¸­å‡ºé”™:", error);
                    // ç¡®ä¿æ¸…ç†å¼ é‡é¿å…å†…å­˜æ³„æ¼
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }

            async trainActor(states) {
                try {
                    const actorOptimizer = tf.train.adam(this.actorLr);
                    const loss = actorOptimizer.minimize(() => {
                        const predictedActions = this.actor.predict(states);
                        const qValues = this.critic.predict([states, predictedActions]);
                        return tf.neg(tf.mean(qValues));
                    }, true); // returnCost = true
                    if (loss) {
                        this.actorLoss = (await loss.data())[0];
                        loss.dispose();
                    }
                } catch (error) {
                    console.error("Actorè®­ç»ƒå‡ºé”™:", error);
                }
            }

            updateTargetNetworks(tau) {
                try {
                    // è½¯æ›´æ–°Actorç›®æ ‡ç½‘ç»œ
                    const actorWeights = this.actor.getWeights();
                    const targetActorWeights = this.targetActor.getWeights();

                    const newActorWeights = actorWeights.map((weight, i) => {
                        return tf.add(
                            tf.mul(weight, tau),
                            tf.mul(targetActorWeights[i], 1 - tau)
                        );
                    });

                    this.targetActor.setWeights(newActorWeights);

                    // è½¯æ›´æ–°Criticç›®æ ‡ç½‘ç»œ
                    const criticWeights = this.critic.getWeights();
                    const targetCriticWeights = this.targetCritic.getWeights();

                    const newCriticWeights = criticWeights.map((weight, i) => {
                        return tf.add(
                            tf.mul(weight, tau),
                            tf.mul(targetCriticWeights[i], 1 - tau)
                        );
                    });

                    this.targetCritic.setWeights(newCriticWeights);
                } catch (error) {
                    console.error("æ›´æ–°ç›®æ ‡ç½‘ç»œå‡ºé”™:", error);
                }
            }

            // å¢åŠ è®­ç»ƒç¨³å®šæ€§æ£€æŸ¥
            checkTrainingStability(reward) {
                this.trainingStability.recentRewards.push(reward);
                if (this.trainingStability.recentRewards.length > 10) {
                    this.trainingStability.recentRewards.shift();
                }

                if (reward > this.trainingStability.bestReward) {
                    this.trainingStability.bestReward = reward;
                    this.trainingStability.noImprovementCount = 0;
                    return false;
                } else {
                    this.trainingStability.noImprovementCount++;

                    // é•¿æ—¶é—´æ²¡æœ‰æ”¹è¿›ï¼Œé‡ç½®å™ªå£°è¿›è¡Œæ›´å¤šæ¢ç´¢
                    if (this.trainingStability.noImprovementCount > 20) {
                        // ä¸ç›´æ¥è®¾ç½®å›ºå®šå€¼ï¼Œè€Œæ˜¯ç›¸å¯¹å¢åŠ ï¼Œé¿å…è¿‡å¤§æ³¢åŠ¨
                        this.noiseScale = Math.min(1.0, this.noiseScale * 1.5);
                        // é‡ç½®OUå™ªå£°çŠ¶æ€ï¼Œå¼•å…¥æ›´å¤šéšæœºæ€§
                        this.noise.reset();
                        this.trainingStability.noImprovementCount = 0;
                        return true; // è¡¨ç¤ºå·²é‡ç½®
                    }
                }
                return false;
            }
        }

        /****************************************************************
         *                     TD3  Agent (åŒ Critic)                    *
         ****************************************************************/
        class TD3Agent extends DDPGAgent {
            constructor(config) {
                super(config);
                // é¢å¤–ç¬¬äºŒå¥— Critic / targetCritic
                this.critic2 = this.createCritic([96, 96, 96]);
                this.targetCritic2 = this.createCritic([96, 96, 96]);
                this.updateTargetNetworks(1.0);
                // TD3 ç‰¹æœ‰è¶…å‚æ•°
                this.policyDelay = 2;     // æ¯ 2 æ­¥æ›´æ–°ä¸€æ¬¡ Actor
                this.policyNoise = 0.2;   // ç›®æ ‡ç­–ç•¥å¹³æ»‘å™ªå£°
                this.policyNoiseClip = 0.5;
                this.trainStep = 0;
            }

            /** å¤å†™ replayï¼šä½¿ç”¨åŒ Critic + å»¶è¿Ÿ Actor æ›´æ–° */
            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { indices, experiences } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // å®‰å…¨æ£€æŸ¥

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // ç›®æ ‡åŠ¨ä½œ + å¹³æ»‘å™ªå£°
                    let nextActions = this.targetActor.predict(nextStates);
                    const noise = tf.randomNormal(nextActions.shape, 0, this.policyNoise);
                    const clippedNoise = tf.clipByValue(noise, -this.policyNoiseClip, this.policyNoiseClip);
                    nextActions = tf.clipByValue(tf.add(nextActions, clippedNoise), 0, 1);

                    // ä¸¤ä¸ª Critic å–æœ€å° Q
                    const nextQ1 = tf.squeeze(this.targetCritic.predict([nextStates, nextActions]));
                    const nextQ2 = tf.squeeze(this.targetCritic2.predict([nextStates, nextActions]));
                    const nextQ = tf.minimum(nextQ1, nextQ2);

                    const targetQ = tf.add(rewards, tf.mul(this.gamma, tf.mul(nextQ, dones)));
                    const targetQExp = tf.expandDims(targetQ, 1);

                    // æ›´æ–°ä¸¤ä¸ª Critic
                    const criticLoss1 = await this.critic.fit([states, actions], targetQExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    const criticLoss2 = await this.critic2.fit([states, actions], targetQExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    this.criticLoss = (criticLoss1.history.loss[0] + criticLoss2.history.loss[0]) / 2;

                    // æ¯ policyDelay æ­¥æ›´æ–°ä¸€æ¬¡ Actor
                    if (this.trainStep % this.policyDelay === 0) {
                        await this.trainActor(states);
                        // è½¯æ›´æ–°æ‰€æœ‰ target ç½‘ç»œ
                        this.updateTargetNetworks(this.tau);
                        // å¦å¤–æ›´æ–°ç¬¬äºŒå¥— Critic ç›®æ ‡
                        const c2W = this.critic2.getWeights(),
                            tc2W = this.targetCritic2.getWeights(),
                            newW2 = c2W.map((w, i) => tf.add(tf.mul(w, this.tau), tf.mul(tc2W[i], 1 - this.tau)));
                        this.targetCritic2.setWeights(newW2);
                    }
                    this.trainStep++;

                    // è¡°å‡å™ªå£° - ä½¿ç”¨ä½™å¼¦è¡°å‡æ›²çº¿
                    if (this.noiseScale > this.minNoiseScale) {
                        const cosDecayRate = this.noiseDecay * (1 + Math.cos(Math.PI * this.trainingStability.noImprovementCount / 30) * 0.1);
                        this.noiseScale = Math.max(
                            this.minNoiseScale,
                            this.noiseScale * cosDecayRate
                        );
                    }

                    // æ¸…ç†å¼ é‡
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextActions, nextQ1, nextQ2, nextQ, targetQ, targetQExp]);
                } catch (error) {
                    console.error("TD3 è®­ç»ƒè¿‡ç¨‹ä¸­å‡ºé”™:", error);
                    // ç¡®ä¿æ¸…ç†å¼ é‡é¿å…å†…å­˜æ³„æ¼
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }
        }

        /****************************************************************
         *                     SAC  Agent (æœ€å¤§ç†µ)                       *
         ****************************************************************/
        class SACAgent extends DDPGAgent {
            constructor(config) {
                super(config);
                // è¦†ç›– actor ä¸º Gaussian policyï¼šè¾“å‡º Î¼, logÏƒ
                this.actor = this.createGaussianActor([96, 96, 96]);
                this.targetActor = this.createGaussianActor([96, 96, 96]);
                this.updateTargetNetworks(1.0);

                // SAC ç‰¹æœ‰è¶…å‚æ•°
                this.alpha = 0.2;   // ç†µæ¸©åº¦ï¼Œå¯è®­ç»ƒä¹Ÿå¯å›ºå®š
                this.targetEntropy = -1; // ç»éªŒæ³•ï¼š-|A|
                this.logAlpha = tf.variable(tf.scalar(Math.log(this.alpha)));
                this.alphaOpt = tf.train.adam(3e-4);

                // ä¸ºSACåˆ›å»ºç¬¬äºŒä¸ªcritic
                this.critic2 = this.createCritic([96, 96, 96]);
                this.targetCritic2 = this.createCritic([96, 96, 96]);
            }

            createGaussianActor(layers) {
                const input = tf.input({ shape: [4] }); // 4ç»´è¾“å…¥ï¼ŒåŒ…å«ç›¸å¯¹æ¸©åº¦ç³»æ•°
                let x = input;

                // æ·»åŠ æ‰¹é‡å½’ä¸€åŒ–
                let normalizedInput = tf.layers.batchNormalization().apply(input);
                x = normalizedInput;

                layers.forEach((units, i) => {
                    x = tf.layers.dense({
                        units,
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }).apply(x);

                    if (i < layers.length - 1) {
                        x = tf.layers.batchNormalization().apply(x);
                    }
                });

                const mu = tf.layers.dense({
                    units: 1,
                    activation: 'tanh',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(x);

                // å¯¹logStdä½¿ç”¨tanhæ¿€æ´»ï¼Œé™åˆ¶è¾“å‡ºèŒƒå›´
                const logStd = tf.layers.dense({
                    units: 1,
                    activation: 'tanh',
                    kernelInitializer: tf.initializers.glorotNormal()
                }).apply(x);

                // æ˜ å°„tanhè¾“å‡ºåˆ°åˆç†çš„logStdèŒƒå›´
                const scaledLogStd = tf.layers.dense({
                    units: 1,
                    activation: 'linear',
                    kernelInitializer: tf.initializers.constant({ value: 0.5 }),
                    biasInitializer: tf.initializers.constant({ value: -1.0 })
                }).apply(logStd); // å°†tanhè¾“å‡ºæ˜ å°„åˆ°[-2, 0]èŒƒå›´

                const model = tf.model({ inputs: input, outputs: [mu, scaledLogStd] });
                return model;
            }

            /** é‡‡æ ·åŠ¨ä½œï¼šreâ€‘parameterization + tanh squash */
            async selectAction(state, waterTemp, targetTemp, training = true) {
                try {
                    const ns = this.normalizeState(state, waterTemp, targetTemp);
                    const sTen = tf.tensor2d([ns]);
                    const [mu, logStd] = this.actor.predict(sTen);

                    // é™åˆ¶logStdèŒƒå›´ï¼Œé¿å…æ•°å€¼ä¸ç¨³å®š
                    const clippedLogStd = tf.clipByValue(logStd, -20, 2);
                    const std = tf.exp(clippedLogStd);

                    let action;
                    if (training) {
                        const eps = tf.randomNormal(std.shape);
                        action = tf.add(mu, tf.mul(std, eps)); // reâ€‘parameterization
                    } else {
                        action = mu; // æµ‹è¯•æ—¶ç›´æ¥ä½¿ç”¨å‡å€¼
                    }

                    action = tf.tanh(action);                  // squash to [-1,1]
                    action = tf.div(tf.add(action, 1), 2);     // -> [0,1]

                    // ç¡®ä¿åŠ¨ä½œåœ¨æœ‰æ•ˆèŒƒå›´å†…
                    action = tf.clipByValue(action, 0, 1);

                    const arr = await action.array();
                    tf.dispose([sTen, mu, logStd, clippedLogStd, std, action]);

                    // è¿”å›ç¼©æ”¾åçš„åŠŸç‡
                    const powerValue = arr[0][0] * this.maxPower;

                    // åœ¨æµ‹è¯•æ¨¡å¼ä¸‹ä½¿ç”¨ç²¾ç¡®æ§åˆ¶
                    if (!training && Math.abs(waterTemp - targetTemp) < 1.0) {
                        return this.preciseControlStrategy(powerValue, waterTemp, targetTemp);
                    }

                    return powerValue;
                } catch (error) {
                    console.error("SACåŠ¨ä½œé€‰æ‹©å‡ºé”™:", error);
                    // å‡ºé”™æ—¶è¿”å›ä¸€ä¸ªå®‰å…¨çš„é»˜è®¤å€¼
                    return this.maxPower * 0.5;
                }
            }

            /** è¦†å†™ replayï¼š2 Critic + entropy ç›®æ ‡ */
            async replay() {
                if (this.replayBuffer.size() < this.batchSize) return;

                const { experiences } = this.replayBuffer.sample(this.batchSize);
                if (experiences.length === 0) return; // å®‰å…¨æ£€æŸ¥

                const states = tf.tensor2d(experiences.map(e => e[0]));
                const actions = tf.tensor2d(experiences.map(e => [e[1]]));
                const rewards = tf.tensor1d(experiences.map(e => e[2]));
                const nextStates = tf.tensor2d(experiences.map(e => e[3]));
                const dones = tf.tensor1d(experiences.map(e => e[4] ? 0 : 1));

                try {
                    // -------- è®¡ç®—ç›®æ ‡ Q --------
                    const [nextMu, nextLogStd] = this.actor.predict(nextStates);
                    const clippedLogStd = tf.clipByValue(nextLogStd, -20, 2);
                    const nextStd = tf.exp(clippedLogStd);
                    const nextEps = tf.randomNormal(nextStd.shape);
                    let nextAction = tf.add(nextMu, tf.mul(nextStd, nextEps));
                    nextAction = tf.tanh(nextAction);
                    const nextActS = tf.div(tf.add(nextAction, 1), 2); // [0,1]

                    // è®¡ç®—logæ¦‚ç‡ - æ›´ç¨³å®šçš„å®ç°
                    const logProb = tf.sub(
                        tf.sum(
                            tf.sub(
                                tf.sub(
                                    tf.mul(-0.5, tf.square(nextEps)),
                                    nextLogStd
                                ),
                                tf.scalar(0.5 * Math.log(2 * Math.PI))
                            ),
                            1, true
                        ),
                        tf.sum(
                            tf.log(tf.sub(tf.scalar(1.0), tf.square(tf.tanh(nextAction)))).add(tf.scalar(1e-6)),
                            1, true
                        )
                    );

                    const targetQ1 = tf.squeeze(this.targetCritic.predict([nextStates, nextActS]));
                    const targetQ2 = tf.squeeze(this.targetCritic2.predict([nextStates, nextActS]));
                    const minTargetQ = tf.minimum(targetQ1, targetQ2);

                    const target = tf.add(rewards,
                        tf.mul(this.gamma,
                            tf.mul(dones,
                                tf.sub(minTargetQ, tf.mul(this.alpha, logProb.squeeze())))));

                    // -------- æ›´æ–°ä¸¤ Critic --------
                    const targetExp = tf.expandDims(target, 1);
                    const loss1 = await this.critic.fit([states, actions], targetExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    const loss2 = await this.critic2.fit([states, actions], targetExp,
                        { epochs: 1, verbose: 0, batchSize: this.batchSize });
                    this.criticLoss = (loss1.history.loss[0] + loss2.history.loss[0]) / 2;

                    // -------- æ›´æ–° Actor & Î± --------
                    const actorOpt = tf.train.adam(this.actorLr);
                    await actorOpt.minimize(() => {
                        const [mu, lstd] = this.actor.predict(states);
                        const cLstd = tf.clipByValue(lstd, -20, 2);
                        const std = tf.exp(cLstd);
                        const eps = tf.randomNormal(std.shape);
                        let act = tf.add(mu, tf.mul(std, eps));
                        act = tf.tanh(act);
                        const actS = tf.div(tf.add(act, 1), 2);

                        const logPi = tf.sub(
                            tf.sum(
                                tf.sub(
                                    tf.sub(
                                        tf.mul(-0.5, tf.square(eps)),
                                        lstd
                                    ),
                                    tf.scalar(0.5 * Math.log(2 * Math.PI))
                                ),
                                1, true
                            ),
                            tf.sum(
                                tf.log(tf.sub(tf.scalar(1.0), tf.square(tf.tanh(act)))).add(tf.scalar(1e-6)),
                                1, true
                            )
                        );

                        const q1 = this.critic.predict([states, actS]);
                        const q2 = this.critic2.predict([states, actS]);
                        const minQ = tf.minimum(q1, q2);

                        const actorLoss = tf.mean(tf.mul(this.alpha, logPi).sub(minQ));
                        // Î± æ¸©åº¦æ›´æ–°
                        const alphaLoss = tf.mean(
                            tf.mul(this.logAlpha, tf.neg(logPi).sub(this.targetEntropy)));
                        this.alphaOpt.minimize(() => alphaLoss, false, [this.logAlpha]);
                        this.alpha = Math.exp((this.logAlpha.dataSync())[0]);

                        mu.dispose(); lstd.dispose(); cLstd.dispose(); std.dispose(); eps.dispose();
                        act.dispose(); actS.dispose(); logPi.dispose(); q1.dispose();
                        q2.dispose(); minQ.dispose(); // keep actorLoss

                        return actorLoss;
                    }, false /* return cost */);

                    // è½¯æ›´æ–°ç›®æ ‡ç½‘ç»œ
                    this.updateTargetNetworks(this.tau);
                    const c2W = this.critic2.getWeights(), tc2W = this.targetCritic2.getWeights(),
                        newW2 = c2W.map((w, i) => tf.add(tf.mul(w, this.tau), tf.mul(tc2W[i], 1 - this.tau)));
                    this.targetCritic2.setWeights(newW2);

                    // æ¸…ç†å¼ é‡
                    tf.dispose([states, actions, rewards, nextStates, dones,
                        nextMu, nextLogStd, clippedLogStd, nextStd, nextEps, nextAction, nextActS,
                        logProb, targetQ1, targetQ2, minTargetQ, target, targetExp]);
                } catch (error) {
                    console.error("SACè®­ç»ƒè¿‡ç¨‹ä¸­å‡ºé”™:", error);
                    // ç¡®ä¿æ¸…ç†å¼ é‡é¿å…å†…å­˜æ³„æ¼
                    tf.dispose([states, actions, rewards, nextStates, dones]);
                }
            }
        }

        // ============= ä¸»æ§åˆ¶å™¨ ==================
        class MLController {
            constructor() {
                this.logContainer = document.getElementById('logContainer');
                this.setupEventListeners();
                this.setupCharts();
                this.isTraining = false;
                this.testSimulating = false;
                this.ddpgAgent = null;

                // è®­ç»ƒæŒ‡æ ‡è®°å½•
                this.trainingMetrics = {
                    episodeErrors: [],
                    episodeRewards: []
                };

            }

            setupCharts() {
                // æ£€æŸ¥Chartæ˜¯å¦å·²åŠ è½½
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js not loaded');
                    return;
                }

                const ctx = document.getElementById('lossChart').getContext('2d');
                this.lossChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'æ€»å¥–åŠ±',
                            data: [],
                            borderColor: '#4CAF50',
                            backgroundColor: 'rgba(76, 175, 80, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'è®­ç»ƒå¥–åŠ±å˜åŒ–'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: { display: true, text: 'å¥–åŠ±å€¼' }
                            },
                            x: {
                                title: { display: true, text: 'è®­ç»ƒè½®æ¬¡' }
                            }
                        }
                    }
                });

                const tdCtx = document.getElementById('tdLossChart').getContext('2d');
                this.tdLossChart = new Chart(tdCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'ActoræŸå¤±',
                            data: [],
                            borderColor: '#FF5722',
                            backgroundColor: 'rgba(255, 87, 34, 0.1)',
                            tension: 0.1,
                            fill: true
                        },
                        {
                            label: 'CriticæŸå¤±',
                            data: [],
                            borderColor: '#2196F3',
                            backgroundColor: 'rgba(33, 150, 243, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Actor/CriticæŸå¤±å˜åŒ–'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'æŸå¤±å€¼' }
                            },
                            x: {
                                title: { display: true, text: 'è®­ç»ƒè½®æ¬¡' }
                            }
                        }
                    }
                });

                // è®­ç»ƒåæ°´æ¸©æ›²çº¿
                const trainCtx = document.getElementById('trainCurveChart').getContext('2d');
                this.trainCurveChart = new Chart(trainCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'ç›®æ ‡æ¸©åº¦',          // æ•°æ®é›† 0
                                data: [],
                                borderColor: '#FF9800',
                                backgroundColor: 'rgba(255,152,0,0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                yAxisID: 'temp'
                            },
                            {
                                label: 'æ°´æ¸©è½¨è¿¹',          // æ•°æ®é›† 1
                                data: [],
                                borderColor: '#4CAF50',
                                backgroundColor: 'rgba(76,175,80,0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2,
                                yAxisID: 'temp'
                            },
                            {
                                label: 'å¥–åŠ±',              // â­ æ–°å¢æ•°æ®é›† 2
                                data: [],
                                borderColor: '#2196F3',
                                backgroundColor: 'rgba(33,150,243,0.05)',
                                fill: true,
                                tension: 0.2,
                                borderWidth: 1,
                                yAxisID: 'reward'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        interaction: { intersect: false, mode: 'index' },
                        plugins: {
                            legend: { position: 'top' },
                            title: { display: true, text: 'æ¯è½®è®­ç»ƒåæ°´æ¸©ä¸å¥–åŠ±å“åº”' }
                        },
                        scales: {
                            temp: {                       // ğŸŒ¡ï¸ æ¸©åº¦ä¸»è½´ï¼ˆå·¦ï¼‰
                                type: 'linear',
                                position: 'left',
                                beginAtZero: false,
                                title: { display: true, text: 'æ¸©åº¦ (Â°C)' }
                            },
                            reward: {                     // ğŸ’° å¥–åŠ±å‰¯è½´ï¼ˆå³ï¼‰
                                type: 'linear',
                                position: 'right',
                                beginAtZero: true,
                                grid: { drawOnChartArea: false },
                                title: { display: true, text: 'å¥–åŠ±' }
                            },
                            x: {
                                title: { display: true, text: 'æ—¶é—´æ­¥' }
                            }
                        }
                    }
                });
                const testCtx = document.getElementById('testCurveChart').getContext('2d');
                this.testCurveChart = new Chart(testCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'ç›®æ ‡æ¸©åº¦',
                                data: [],
                                borderColor: '#FF9800',
                                backgroundColor: 'rgba(255, 152, 0, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'å®é™…æ°´æ¸©',
                                data: [],
                                borderColor: '#2196F3',
                                backgroundColor: 'rgba(33, 150, 243, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'åŠ çƒ­åŠŸç‡',
                                data: [],
                                borderColor: '#9C27B0',
                                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                                fill: false,
                                tension: 0.1,
                                yAxisID: 'power',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'å®æ—¶æ§æ¸©è¿‡ç¨‹'
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                title: { display: true, text: 'æ¸©åº¦ (Â°C)' }
                            },
                            power: {
                                type: 'linear',
                                position: 'right',
                                beginAtZero: true,
                                title: { display: true, text: 'åŠŸç‡ (W)' },
                                grid: { drawOnChartArea: false }
                            },
                            x: {
                                title: { display: true, text: 'æ—¶é—´æ­¥' }
                            }
                        }
                    }
                });

                // æ–°å¢: æ¸©åº¦è¯¯å·®æ›²çº¿
                const errorCtx = document.getElementById('errorChart').getContext('2d');
                this.errorChart = new Chart(errorCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'å¹³å‡æ¸©åº¦è¯¯å·®',
                                data: [],
                                borderColor: '#E91E63',
                                backgroundColor: 'rgba(233, 30, 99, 0.1)',
                                fill: true,
                                tension: 0.1,
                                borderWidth: 2
                            },
                            {
                                label: 'æœ€å¤§æ¸©åº¦è¯¯å·®',
                                data: [],
                                borderColor: '#FF5722',
                                backgroundColor: 'rgba(255, 87, 34, 0.1)',
                                fill: false,
                                tension: 0.1,
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'è®­ç»ƒè¿‡ç¨‹æ¸©åº¦è¯¯å·®å˜åŒ–'
                            },
                            legend: { display: true }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'æ¸©åº¦è¯¯å·® (Â°C)' }
                            },
                            x: {
                                title: { display: true, text: 'è®­ç»ƒè½®æ¬¡' }
                            }
                        }
                    }
                });
            }

            setupEventListeners() {
                document.getElementById('startTraining').addEventListener('click',
                    () => this.startTraining());
                document.getElementById('stopTraining').addEventListener('click',
                    () => this.stopTraining());
                document.getElementById('saveModel').addEventListener('click',
                    () => this.saveModel());
                document.getElementById('loadModel').addEventListener('click',
                    () => this.loadModel());
                document.getElementById('testModel').addEventListener('click',
                    () => this.testModel());
                document.getElementById('stopTest').addEventListener('click',
                    () => this.stopTestModel());
            }

            log(message, type = 'info') {
                const logContainer = this.logContainer;
                const timestamp = new Date().toLocaleTimeString();
                let color = '#666';

                if (type === 'success') color = '#4CAF50';
                if (type === 'warning') color = '#FF9800';
                if (type === 'error') color = '#F44336';

                logContainer.innerHTML += `<span style="color: ${color};">[${timestamp}]</span> ${message}<br>`;
                logContainer.scrollTop = logContainer.scrollHeight;
            }

            updateStatus(message) {
                document.getElementById('status').textContent = message;
            }

            updateProgressBar(current, total) {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                const percent = Math.round((current / total) * 100);

                progressBar.style.width = `${percent}%`;
                progressText.textContent = `${percent}% (${current}/${total})`;
                document.getElementById('trainingProgress').style.display = 'block';
            }

            updateTrainingMetrics(episode, totalEpisodes, reward, noise, tempErrors) {
                document.getElementById('currentEpisode').textContent = `${episode}/${totalEpisodes}`;
                document.getElementById('currentNoise').textContent = `${(noise * 100).toFixed(1)}%`;

                // è®¡ç®—å¹³å‡å¥–åŠ±
                const avgReward = this.trainingMetrics.episodeRewards
                    .slice(-10)
                    .reduce((sum, val) => sum + val, 0) /
                    Math.min(10, this.trainingMetrics.episodeRewards.length);
                document.getElementById('avgReward').textContent = avgReward.toFixed(1);

                // è®¡ç®—å¹³å‡è¯¯å·®
                let avgError = 0;
                if (tempErrors && tempErrors.length > 0) {
                    avgError = tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length;
                }
                document.getElementById('avgError').textContent = avgError.toFixed(2);
            }

            updateMetrics(temp, error, power, reward) {
                document.getElementById('currentTemp').textContent = temp.toFixed(1);
                document.getElementById('currentError').textContent = error.toFixed(2);
                document.getElementById('currentPower').textContent = power.toFixed(0);
                document.getElementById('currentReward').textContent = reward.toFixed(1);
                document.getElementById('metricsPanel').style.display = 'block';
            }

            /**  è®­ç»ƒåå¿«é€Ÿæ¨¡æ‹Ÿä¸€æ¬¡å‡æ¸©æ›²çº¿ï¼Œç”¨äºå¯è§†åŒ–æ”¹è¿›æ•ˆæœ  */
            async evaluateTrainingCurve(agent, config, targetTemp, maxSimSteps = 600) {
                // targetTemp å¿…é¡»ç”±è°ƒç”¨æ–¹ä¼ å…¥ï¼ˆæ¯è½®ä¸åŒï¼‰ï¼Œä¸å¯å†ç”¨ config.targetTemp
                let waterTemp = config.initTemp;
                let lastWaterTemp = waterTemp;
                let dTdt = 0;
                let lastPower = 0;
                const rewardTrace = [];
                const tempTrace = [];
                const tempErrors = [];
                // ç›®æ ‡æ¸©åº¦æ›²çº¿å…¨ç¨‹ç”¨ä¼ å…¥çš„ targetTemp
                const setTrace = Array(maxSimSteps).fill(targetTemp);

                for (let step = 0; step < maxSimSteps; step++) {
                    // æ ¸å¿ƒ3é‡ + æ°´æ¸©å’Œç›®æ ‡æ¸©åº¦
                    const state = [
                        waterTemp - targetTemp,
                        lastWaterTemp,
                        lastPower / agent.maxPower
                    ];

                    const power = await agent.selectAction(state, waterTemp, targetTemp, false);

                    // ç¯å¢ƒæ¨¡å‹
                    const deltaT = (power - config.hA * (waterTemp - config.roomTemp)) /
                        (config.waterMass * 4184);
                    const nextTemp = waterTemp + deltaT;
                    dTdt = (nextTemp - waterTemp) / config.deltaT;
                    lastWaterTemp = waterTemp;
                    waterTemp = nextTemp;
                    lastPower = power;
                    tempTrace.push(waterTemp);

                    // è®¡ç®—æ¸©åº¦è¯¯å·®
                    const error = Math.abs(waterTemp - targetTemp);
                    tempErrors.push(error);

                    const reward = agent.calculateReward(waterTemp, targetTemp, power, lastWaterTemp, step);
                    rewardTrace.push(reward);

                    if (error < 0.1 && step > 200) break;
                }

                if (this.trainCurveChart) {
                    this.trainCurveChart.data.labels = tempTrace.map((_, i) => i);
                    // ç›®æ ‡æ¸©åº¦è½¨è¿¹å¿…é¡»å…¨ç¨‹ç”¨ä¼ å…¥çš„ targetTemp
                    this.trainCurveChart.data.datasets[0].data = setTrace.slice(0, tempTrace.length);
                    this.trainCurveChart.data.datasets[1].data = tempTrace;
                    this.trainCurveChart.data.datasets[2].data = rewardTrace;
                    
                    this.trainCurveChart.update('none');

                }

                return {
                    avgError: tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length,
                    maxError: Math.max(...tempErrors),
                    finalError: tempErrors[tempErrors.length - 1],
                    stepCount: tempTrace.length
                };
            }

            async startTraining() {
                const algorithm = document.getElementById('algorithmSelect').value;
                if (this.isTraining) return;

                this.isTraining = true;
                this.updateStatus(`ğŸš€ ${algorithm.toUpperCase()} å¼ºåŒ–å­¦ä¹ è®­ç»ƒä¸­...`);

                // é‡ç½®è®­ç»ƒæŒ‡æ ‡
                this.trainingMetrics = {
                    episodeErrors: [],
                    episodeRewards: []
                };

                if (this.lossChart) {
                    this.lossChart.data.labels = [];
                    this.lossChart.data.datasets[0].data = [];
                    this.lossChart.update();
                }

                if (this.tdLossChart) {
                    this.tdLossChart.data.labels = [];
                    this.tdLossChart.data.datasets[0].data = [];
                    this.tdLossChart.data.datasets[1].data = [];
                    this.tdLossChart.update();
                }

                if (this.errorChart) {
                    this.errorChart.data.labels = [];
                    this.errorChart.data.datasets[0].data = [];
                    this.errorChart.data.datasets[1].data = [];
                    this.errorChart.update();
                }

                const config = {
                    maxPower: parseFloat(document.getElementById('maxPowerInput').value),
                    targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),   // ä»…æµ‹è¯•é˜¶æ®µä½¿ç”¨
                    initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                    roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                    hA: parseFloat(document.getElementById('hAInput').value),
                    waterMass: parseFloat(document.getElementById('waterMassInput').value),
                    deltaT: parseFloat(document.getElementById('deltaT').value)
                };

                // ç¦æ­¢è®­ç»ƒæœŸé—´ä½¿ç”¨å›ºå®š targetTemp
                config.targetTemp = null;

                // åŠ¨æ€è®¡ç®—åˆç†çš„ç›®æ ‡æ¸©åº¦èŒƒå›´ï¼ŒåŸºäºç¯å¢ƒæ¸©åº¦å’Œæœ€å¤§åŠŸç‡
                const minTemp = Math.max(25, config.roomTemp + 5); // è‡³å°‘é«˜äºå®¤æ¸©5åº¦
                const maxTemp = Math.min(95, config.roomTemp + config.maxPower / 40); // åŸºäºæœ€å¤§åŠŸç‡çš„å¯è¾¾æ¸©åº¦
                config.targetMin = minTemp;
                config.targetMax = maxTemp;

                this.log(`ğŸ¯ å¼€å§‹ ${algorithm.toUpperCase()} æ™ºèƒ½æ§æ¸©è®­ç»ƒ...`);
                this.log(`ğŸ“Š è®­ç»ƒç›®æ ‡æ¸©åŒºåŠ¨æ€è°ƒæ•´ä¸º: ${minTemp.toFixed(1)}â€‘${maxTemp.toFixed(1)}Â°Cï¼ŒåŸºäºå®¤æ¸©${config.roomTemp}Â°C`);

                let episodeTarget = null;
                try {
                    if (algorithm === 'td3') {
                        this.ddpgAgent = new TD3Agent(config);
                    } else if (algorithm === 'sac') {
                        this.ddpgAgent = new SACAgent(config);
                    } else {
                        this.ddpgAgent = new DDPGAgent(config);
                    }

                    const nEpisodes = parseInt(document.getElementById('epochs').value) || 200;
                    // === å›ºå®šå›åˆæ­¥æ•°ï¼Œä¸“æ³¨å…ˆæŠŠè®­ç»ƒè·‘é€š ===
                    const maxSteps = 2000;                // æ¯å›åˆ 2000 æ­¥
                    console.log(`ğŸ’¡ Episode duration fixed at ${maxSteps} steps`);
                    const tolerance = 0.05;          // ç›®æ ‡ç¨³æ€ç²¾åº¦ Â±0.05 Â°C

                    let bestReward = -Infinity;
                    let bestActorWeights = null;
                    let bestCriticWeights = null;
                    let recentRewards = [];

                    let lastPower = 0;
                    // === åŒé˜¶æ®µ: å‡æ¸© + ç¨³æ€è€ƒå¯Ÿ ===
                    const steadyNeeded = 500;         // ç¨³æ€éœ€æŒç»­æ­¥æ•°

                    for (let episode = 0; episode < nEpisodes; episode++) {
                        if (!this.isTraining) {
                            this.updateStatus('âŒ è®­ç»ƒå·²åœæ­¢');
                            this.log('â¹ï¸ è®­ç»ƒè¢«ç”¨æˆ·ä¸­æ­¢');
                            return;
                        }

                        // æ›´æ–°è®­ç»ƒè¿›åº¦æ¡
                        this.updateProgressBar(episode + 1, nEpisodes);

                        // å®ç°è¯¾ç¨‹å­¦ä¹  - å¾ªåºæ¸è¿›æé«˜éš¾åº¦
                        let episodeTargetRange;
                        if (episode < nEpisodes * 0.3) {
                            // å‰30%è½®æ¬¡ï¼šåœ¨è¾ƒçª„èŒƒå›´å†…è®­ç»ƒ
                            const targetMid = (config.targetMin + config.targetMax) / 2;
                            const narrowRange = (config.targetMax - config.targetMin) * 0.3;
                            episodeTarget = targetMid - narrowRange / 2 + Math.random() * narrowRange;
                        } else {
                            // åç»­é€æ­¥æ‰©å¤§èŒƒå›´
                            const progress = Math.min(1.0, (episode - nEpisodes * 0.3) / (nEpisodes * 0.7));
                            const range = (config.targetMax - config.targetMin) * (0.3 + 0.7 * progress);
                            const targetMid = (config.targetMin + config.targetMax) / 2;
                            episodeTarget = targetMid - range / 2 + Math.random() * range;
                        }

                        // åŠ¨æ€è°ƒæ•´åˆå§‹æ°´æ¸© - é è¿‘ä½†ä½äºç›®æ ‡æ¸©åº¦
                        let waterTemp = config.roomTemp + (episodeTarget - config.roomTemp) * (0.3 + 0.5 * Math.random());

                        let dTdt = 0;
                        let lastWaterTemp = waterTemp;
                        let state = [waterTemp - episodeTarget, lastWaterTemp, 0];
                        let totalReward = 0;

                        // è‹¥æœ¬å›åˆæœªèƒ½è¿›å…¥å®¹å·®åŒºé—´ï¼Œåˆ™ä¿æŒ null âœ æ—¥å¿—æ˜¾ç¤º"æœªè¾¾"
                        let stepsToTarget = null;
                        let warmUpDone = false;
                        let steadySteps = 0;

                        let stableCount = 0;
                        // æ”¶é›†æ¸©åº¦è¯¯å·®
                        const tempErrors = [];

                        for (let step = 0; step < maxSteps; step++) {
                            if (!this.isTraining) break;

                            // æ›´æ–°åçš„ selectAction ä¼ å…¥å½“å‰æ°´æ¸©å’Œç›®æ ‡æ¸©åº¦
                            const heatingPower = await this.ddpgAgent.selectAction(state, waterTemp, episodeTarget, true);
                            const deltaT = (heatingPower - config.hA * (waterTemp - config.roomTemp)) / (config.waterMass * 4184);
                            const nextWaterTemp = waterTemp + deltaT;
                            const nextDTdt = (nextWaterTemp - waterTemp) / config.deltaT;
                            const nextState = [
                                nextWaterTemp - episodeTarget,
                                waterTemp,
                                heatingPower / this.ddpgAgent.maxPower
                            ];

                            // æ”¹è¿›çš„å¥–åŠ±å‡½æ•° - æ¥æ”¶æ°´æ¸©å’Œç›®æ ‡æ¸©åº¦
                            const reward = this.ddpgAgent.calculateReward(nextWaterTemp, episodeTarget, heatingPower, lastWaterTemp, step);

                            // æ”¹è¿›çš„è®°å¿†å‡½æ•°ï¼Œä¼ å…¥æ›´å¤šæ¸©åº¦ä¿¡æ¯
                            this.ddpgAgent.remember(state, heatingPower, reward, nextState, false, waterTemp, episodeTarget, nextWaterTemp);

                            lastPower = heatingPower;
                            state = nextState;
                            lastWaterTemp = waterTemp;
                            waterTemp = nextWaterTemp;
                            totalReward += reward;

                            // æ”¶é›†è¯¯å·®æ•°æ®
                            const tempError = Math.abs(waterTemp - episodeTarget);
                            tempErrors.push(tempError);

                            const inTol = tempError < tolerance;

                            if (inTol && !warmUpDone) {
                                warmUpDone = true;
                                stepsToTarget = step;
                            }

                            if (warmUpDone) {
                                const tempSlope = Math.abs(nextDTdt);
                                if (tempSlope < 0.02) {
                                    steadySteps++;
                                } else {
                                    steadySteps = 0;
                                }

                                if (steadySteps >= steadyNeeded) {
                                    break;
                                }
                            }
                            if (Math.abs(waterTemp - episodeTarget) < 0.3) {
                                stableCount++;
                            } else {
                                stableCount = 0;
                            }
                            // æ–°çš„æå‰ç»ˆæ­¢é€»è¾‘ï¼šè¿›å…¥ç›®æ ‡åŒºé—´åè€ƒå¯Ÿä¸€å®šç¨³å®šæ—¶é—´
                            if (stableCount > 0 && stableCount % 50 === 0) {
                                const avgError = Math.abs(waterTemp - episodeTarget);
                                if (avgError < 0.2) {
                                    this.log(`ğŸ¯ ç¬¬${episode + 1}è½®: æ§æ¸©å·²ç¨³å®šåœ¨ç›®æ ‡è¯¯å·®èŒƒå›´å†…ï¼Œæå‰ç»“æŸ`);
                                    break;
                                }
                            }
                        }

                        // æ¯å›åˆç»“æŸåå¢åŠ æ›´å¤šçš„å›æ”¾è®­ç»ƒ
                        const replayCount = Math.min(10, Math.floor(episode / 20) + 1);
                        for (let i = 0; i < replayCount; i++) {
                            await this.ddpgAgent.replay();
                        }

                        // ä¿å­˜è®­ç»ƒæŒ‡æ ‡
                        this.trainingMetrics.episodeRewards.push(totalReward);
                        if (tempErrors.length > 0) {
                            const avgError = tempErrors.reduce((sum, val) => sum + val, 0) / tempErrors.length;
                            const maxError = Math.max(...tempErrors);
                            this.trainingMetrics.episodeErrors.push({ avg: avgError, max: maxError });

                            // æ›´æ–°è¯¯å·®æ›²çº¿
                            if (this.errorChart) {
                                this.errorChart.data.labels.push(episode + 1);
                                this.errorChart.data.datasets[0].data.push(avgError);
                                this.errorChart.data.datasets[1].data.push(maxError);
                                this.errorChart.update('none');
                            }
                        }

                        // æ›´æ–°è®­ç»ƒæŒ‡æ ‡é¢æ¿
                        this.updateTrainingMetrics(
                            episode + 1, nEpisodes,
                            totalReward,
                            this.ddpgAgent.noiseScale,
                            tempErrors
                        );

                        recentRewards.push(totalReward);
                        if (recentRewards.length > 10) recentRewards.shift();

                        if (this.lossChart) {
                            this.lossChart.data.labels.push(episode + 1);
                            this.lossChart.data.datasets[0].data.push(totalReward);
                            this.lossChart.update('none');
                        }

                        if (this.tdLossChart) {
                            this.tdLossChart.data.labels.push(episode + 1);
                            this.tdLossChart.data.datasets[0].data.push(Math.abs(this.ddpgAgent.actorLoss || 0));
                            this.tdLossChart.data.datasets[1].data.push(this.ddpgAgent.criticLoss || 0);
                            this.tdLossChart.update('none');
                        }

                        // æ£€æŸ¥è®­ç»ƒç¨³å®šæ€§å¹¶å¯èƒ½é‡ç½®æ¢ç´¢
                        const resetExploration = this.ddpgAgent.checkTrainingStability(totalReward);
                        if (resetExploration) {
                            this.log(`ğŸ”„ ç¬¬${episode + 1}è½®: é‡ç½®æ¢ç´¢ç­–ç•¥ï¼Œå¢å¤§å™ªå£°è‡³ ${(this.ddpgAgent.noiseScale * 100).toFixed(1)}%`, 'warning');
                        }

                        if (totalReward > bestReward) {
                            bestReward = totalReward;
                            // 1ï¸âƒ£ å…ˆé‡Šæ”¾æ—§å¿«ç…§
                            if (bestActorWeights) bestActorWeights.forEach(t => t.dispose());
                            if (bestCriticWeights) bestCriticWeights.forEach(t => t.dispose());

                            // 2ï¸âƒ£ clone æ·±æ‹·è´ï¼Œé”å®šå¿«ç…§
                            bestActorWeights = this.ddpgAgent.actor.getWeights().map(t => t.clone());
                            bestCriticWeights = this.ddpgAgent.critic.getWeights().map(t => t.clone());

                            this.log(`ğŸ† ç¬¬${episode + 1}è½®: å‘ç°æœ€ä½³æ¨¡å‹! å¥–åŠ±: ${bestReward.toFixed(1)}`, 'success');
                        }

                        const avgReward = recentRewards.reduce((a, b) => a + b, 0) / recentRewards.length;
                        this.updateStatus(
                            `ğŸ”¥ è®­ç»ƒä¸­: ${episode + 1}/${nEpisodes} | ` +
                            `ç›®æ ‡:${episodeTarget.toFixed(1)}Â°C | ` +
                            `å™ªå£°: ${(this.ddpgAgent.noiseScale * 100).toFixed(1)}% | ` +
                            `å¥–åŠ±: ${totalReward.toFixed(1)} | ` +
                            `å¹³å‡: ${avgReward.toFixed(1)}`
                        );

                        // è®¡ç®—æ¸©åº¦è¯¯å·®æŒ‡æ ‡
                        const avgError = tempErrors.reduce((a, b) => a + b, 0) / tempErrors.length;
                        const maxError = Math.max(...tempErrors);

                        this.log(
                            `ğŸ“ˆ ç¬¬${episode + 1}è½®: å¥–åŠ±=${totalReward.toFixed(1)}, ` +
                            `ç›®æ ‡æ¸©åº¦=${episodeTarget.toFixed(1)}Â°C, ` +
                            `å™ªå£°=${(this.ddpgAgent.noiseScale * 100).toFixed(1)}%, ` +
                            `å¹³å‡è¯¯å·®=${avgError.toFixed(2)}Â°C, ` +
                            `åˆ°è¾¾ç›®æ ‡ç”¨æ—¶=${stepsToTarget !== null ? stepsToTarget : 'æœªè¾¾'}æ­¥`
                        );

                        // æ¯ 5 è½®æˆ–æœ€åä¸€è½®ï¼Œå¿«é€Ÿè¯„ä¼°ä¸€æ¬¡å‡æ¸©æ›²çº¿
                        if (episode % 5 === 0 || episode === nEpisodes - 1) {
                            // å¿…é¡»ç”¨æœ¬è½®çš„ episodeTarget ä¼ å…¥ evaluateTrainingCurve
                            const evalResults = await this.evaluateTrainingCurve(this.ddpgAgent, config, episodeTarget, 600);

                            // å¦‚æœæ˜¯æœ€åä¸€è½®ï¼Œæ˜¾ç¤ºè¯¦ç»†çš„è¯„ä¼°ç»“æœ
                            if (episode === nEpisodes - 1) {
                                this.log(
                                    `ğŸ“Š æœ€ç»ˆæ¨¡å‹è¯„ä¼°: ` +
                                    `å¹³å‡æ¸©åº¦è¯¯å·®=${evalResults.avgError.toFixed(2)}Â°C, ` +
                                    `æœ€å¤§è¯¯å·®=${evalResults.maxError.toFixed(2)}Â°C, ` +
                                    `æœ€ç»ˆè¯¯å·®=${evalResults.finalError.toFixed(2)}Â°C, ` +
                                    `ç”¨æ—¶=${evalResults.stepCount}æ­¥`,
                                    'success'
                                );
                            }
                        }

                        await tf.nextFrame();
                    }

                    if (bestActorWeights && bestCriticWeights) {
                        await this.ddpgAgent.actor.setWeights(bestActorWeights);
                        await this.ddpgAgent.critic.setWeights(bestCriticWeights);
                        this.log(`ğŸ† å·²åŠ è½½æœ€ä½³æ¨¡å‹ (å¥–åŠ±: ${bestReward.toFixed(1)})`, 'success');
                    }

                    this.updateStatus(`âœ… ${algorithm.toUpperCase()} è®­ç»ƒå®Œæˆï¼å¯ä»¥å¼€å§‹æµ‹è¯•æ§æ¸©æ•ˆæœ`);
                    this.log('ğŸ‰ è®­ç»ƒå®Œæˆï¼æ™ºèƒ½ä½“å·²å‡†å¤‡å°±ç»ªï¼Œå¯è¿›è¡Œæ§æ¸©æµ‹è¯•', 'success');

                    /* === è®­ç»ƒç»“æŸ: æ¢å¤å†å²æœ€ä½³å¿«ç…§ === */
                    if (bestActorWeights) {
                        const actorSnap = bestActorWeights.map(t => t.clone());   // clone é˜²æ­¢ä¿®æ”¹å¤‡ä»½
                        this.ddpgAgent.actor.setWeights(actorSnap);
                        this.ddpgAgent.targetActor.setWeights(actorSnap);
                    }
                    if (bestCriticWeights) {
                        const criticSnap = bestCriticWeights.map(t => t.clone());
                        this.ddpgAgent.critic.setWeights(criticSnap);
                        this.ddpgAgent.targetCritic.setWeights(criticSnap);
                    }
                    // è®­ç»ƒå®Œæˆåè¯„ä¼°ä¸€æ¬¡å‡æ¸©æ›²çº¿ï¼ˆç”¨æ¥è¿‘ä¸­é—´å€¼çš„ç›®æ ‡æ¸©åº¦ï¼‰
                    const finalTarget = (config.targetMin + config.targetMax) / 2;
                    await this.evaluateTrainingCurve(this.ddpgAgent, config, finalTarget, 600);

                } catch (error) {
                    this.updateStatus('âŒ è®­ç»ƒå‡ºé”™: ' + error.message);
                    this.log('ğŸ’¥ è®­ç»ƒé”™è¯¯: ' + error.message, 'error');
                    console.error('Training error:', error);
                } finally {
                    this.isTraining = false;
                }
            }

            stopTraining() {
                this.isTraining = false;
                this.updateStatus('â¹ï¸ æ­£åœ¨åœæ­¢è®­ç»ƒ...');
            }

            async testModel() {
                if (!this.ddpgAgent) {
                    this.log('âŒ æ²¡æœ‰å¯ç”¨çš„è®­ç»ƒæ¨¡å‹ï¼Œè¯·å…ˆè¿›è¡Œè®­ç»ƒ', 'error');
                    return;
                }

                if (this.testSimulating) {
                    this.log('âš ï¸ æ§æ¸©æµ‹è¯•å·²åœ¨è¿è¡Œä¸­', 'warning');
                    return;
                }

                this.testSimulating = true;
                document.getElementById('stopTest').style.display = 'inline-block';
                this.updateStatus('ğŸ§ª æ™ºèƒ½æ§æ¸©æµ‹è¯•ä¸­...');
                this.log('ğŸš€ å¼€å§‹æ™ºèƒ½æ§æ¸©æµ‹è¯•...');

                // === å¢åŠ ç¨³æ€è€ƒå¯Ÿå˜é‡ ===
                let inTargetZone = false;
                let stableCount = 0;
                const stabilizationSteps = 500; // ç¨³æ€è€ƒå¯Ÿæ­¥æ•°

                try {
                    const config = {
                        targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),
                        initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                        roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                        hA: parseFloat(document.getElementById('hAInput').value),
                        waterMass: parseFloat(document.getElementById('waterMassInput').value),
                        deltaT: parseFloat(document.getElementById('deltaT').value)
                    };

                    let lastPower = 0;
                    let waterTemp = config.initTemp;
                    let lastWaterTemp = waterTemp;
                    let dTdt = 0;
                    let step = 0;
                    const tempTrace = [];
                    const powerTrace = [];
                    const setTrace = [];
                    const tolerance = 0.05;

                    let state = [
                        waterTemp - config.targetTemp,
                        dTdt,
                        lastPower / this.ddpgAgent.maxPower
                    ];


                    const tempErrors = [];

                    while (this.testSimulating && step < 1000) {
                        // ä¼ å…¥å½“å‰æ°´æ¸©å’Œç›®æ ‡æ¸©åº¦ï¼Œä½¿ç”¨ç›¸å¯¹æ¸©åº¦å› å­
                        const heatingPower = await this.ddpgAgent.selectAction(state, waterTemp, config.targetTemp, false);
                        const deltaT = (heatingPower - config.hA * (waterTemp - config.roomTemp)) / (config.waterMass * 4184);
                        const nextWaterTemp = waterTemp + deltaT;
                        const nextDTdt = (nextWaterTemp - waterTemp) / config.deltaT;

                        tempTrace.push(nextWaterTemp);
                        powerTrace.push(heatingPower);
                        setTrace.push(config.targetTemp);

                        // æ”¶é›†è¯¯å·®æ•°æ®
                        const tempError = Math.abs(nextWaterTemp - config.targetTemp);
                        tempErrors.push(tempError);

                        if (this.testCurveChart) {
                            this.testCurveChart.data.labels = tempTrace.map((_, i) => i);
                            this.testCurveChart.data.datasets[0].data = setTrace;
                            this.testCurveChart.data.datasets[1].data = tempTrace;
                            this.testCurveChart.data.datasets[2].data = powerTrace;
                            this.testCurveChart.update('none');
                        }

                        state = [
                            nextWaterTemp - config.targetTemp,
                            nextDTdt,
                            heatingPower / this.ddpgAgent.maxPower
                        ];

                        const reward = this.ddpgAgent.calculateReward(nextWaterTemp, config.targetTemp, heatingPower, lastWaterTemp, step);
                        lastPower = heatingPower;
                        lastWaterTemp = waterTemp;
                        waterTemp = nextWaterTemp;

                        this.updateMetrics(waterTemp, tempError, heatingPower, reward);
                        this.updateStatus(
                            `ğŸŒ¡ï¸ æ§æ¸©ä¸­: å½“å‰${waterTemp.toFixed(1)}Â°C | ` +
                            `ç›®æ ‡${config.targetTemp}Â°C | ` +
                            `è¯¯å·®${tempError.toFixed(2)}Â°C | ` +
                            `åŠŸç‡${heatingPower.toFixed(0)}W`
                        );

                        if (Math.abs(waterTemp) > 200) {
                            this.log('âš ï¸ æ£€æµ‹åˆ°æ¸©åº¦å¼‚å¸¸ï¼Œé‡ç½®ç¯å¢ƒ', 'warning');
                            waterTemp = config.initTemp;
                            lastWaterTemp = waterTemp;
                            dTdt = 0;
                            lastPower = 0;
                            state = [
                                waterTemp - config.targetTemp,
                                dTdt,
                                lastPower / this.ddpgAgent.maxPower
                            ];
                        }

                        step++;

                        // æ–°çš„æå‰ç»ˆæ­¢é€»è¾‘ï¼šè¿›å…¥ç›®æ ‡åŒºé—´åè€ƒå¯ŸstabilizationStepsæ­¥
                        if (!inTargetZone && tempError < tolerance) {
                            inTargetZone = true;
                            stableCount = 0;
                            this.log('ğŸŒˆ å·²è¿›å…¥ç›®æ ‡åŒºé—´ï¼Œå¼€å§‹ç¨³æ€æ€§èƒ½è€ƒå¯Ÿ...', 'success');
                        }

                        if (inTargetZone) {
                            stableCount++;
                            if (stableCount >= stabilizationSteps) {
                                this.log(`ğŸ¯ ç¨³æ€è€ƒå¯Ÿå®Œæˆï¼Œæ€»æ­¥æ•°ï¼š${step}, æµ‹è¯•ç»ˆæ­¢`, 'success');

                                // è®¡ç®—ç¨³æ€é˜¶æ®µçš„æ€§èƒ½æŒ‡æ ‡
                                const stableErrors = tempErrors.slice(-stabilizationSteps);
                                const avgStableError = stableErrors.reduce((sum, val) => sum + val, 0) / stableErrors.length;
                                const maxStableError = Math.max(...stableErrors);

                                this.log(
                                    `ğŸ“Š ç¨³æ€æ§åˆ¶æ€§èƒ½: ` +
                                    `å¹³å‡è¯¯å·®=${avgStableError.toFixed(3)}Â°C, ` +
                                    `æœ€å¤§è¯¯å·®=${maxStableError.toFixed(3)}Â°C`,
                                    'success'
                                );

                                break;
                            }
                        }

                        const simSpeed = parseFloat(document.getElementById('simSpeed').value);
                        if (simSpeed > 0) {
                            await new Promise(resolve => setTimeout(resolve, simSpeed * 1000));
                        } else {
                            await tf.nextFrame();
                        }
                    }

                } catch (error) {
                    this.updateStatus('âŒ æµ‹è¯•å‡ºé”™: ' + error.message);
                    this.log('ğŸ’¥ æµ‹è¯•é”™è¯¯: ' + error.message, 'error');
                    console.error('Test error:', error);
                } finally {
                    this.testSimulating = false;
                    document.getElementById('stopTest').style.display = 'none';
                    this.updateStatus('â¹ï¸ æ§æ¸©æµ‹è¯•å·²åœæ­¢');
                    this.log('ğŸ æ§æ¸©æµ‹è¯•ç»“æŸ');
                }
            }

            stopTestModel() {
                this.testSimulating = false;
                document.getElementById('stopTest').style.display = 'none';
                this.updateStatus('â¹ï¸ æ­£åœ¨åœæ­¢æµ‹è¯•...');
            }

            async saveModel() {
                if (!this.ddpgAgent?.actor || !this.ddpgAgent?.critic) {
                    this.log('âŒ æ²¡æœ‰å¯ä¿å­˜çš„æ¨¡å‹', 'error');
                    return;
                }

                try {
                    await this.ddpgAgent.actor.save('downloads://ddpg-actor-model');
                    await this.ddpgAgent.critic.save('downloads://ddpg-critic-model');
                    this.log('ğŸ’¾ Actorå’ŒCriticæ¨¡å‹ä¿å­˜æˆåŠŸ', 'success');
                    this.updateStatus('âœ… æ¨¡å‹å·²ä¿å­˜åˆ°ä¸‹è½½æ–‡ä»¶å¤¹');
                } catch (error) {
                    this.log('âŒ æ¨¡å‹ä¿å­˜å¤±è´¥: ' + error.message, 'error');
                    this.updateStatus('âŒ ä¿å­˜å¤±è´¥');
                }
            }

            async loadModel() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.multiple = true;

                input.onchange = async (event) => {
                    try {
                        const files = Array.from(event.target.files);

                        // éœ€è¦åŠ è½½Actorå’ŒCriticä¸¤ä¸ªæ¨¡å‹
                        this.log('ğŸ“ è¯·é€‰æ‹©Actoræ¨¡å‹æ–‡ä»¶...');
                        const actorModel = await tf.loadLayersModel(tf.io.browserFiles(files));

                        this.log('ğŸ“ è¯·å†æ¬¡é€‰æ‹©Criticæ¨¡å‹æ–‡ä»¶...');
                        const input2 = document.createElement('input');
                        input2.type = 'file';
                        input2.accept = '.json';
                        input2.multiple = true;

                        input2.onchange = async (event2) => {
                            try {
                                const files2 = Array.from(event2.target.files);
                                const criticModel = await tf.loadLayersModel(tf.io.browserFiles(files2));

                                const config = {
                                    maxPower: parseFloat(document.getElementById('maxPowerInput').value),
                                    targetTemp: parseFloat(document.getElementById('targetWaterTemp').value),
                                    initTemp: parseFloat(document.getElementById('initWaterTemp').value),
                                    roomTemp: parseFloat(document.getElementById('roomTempInput').value),
                                    hA: parseFloat(document.getElementById('hAInput').value),
                                    waterMass: parseFloat(document.getElementById('waterMassInput').value)
                                };

                                this.ddpgAgent = new DDPGAgent(config);
                                this.ddpgAgent.actor = actorModel;
                                this.ddpgAgent.critic = criticModel;
                                this.ddpgAgent.updateTargetNetworks(1.0);

                                this.log('ğŸ“ Actorå’ŒCriticæ¨¡å‹åŠ è½½æˆåŠŸ', 'success');
                                this.updateStatus('âœ… æ¨¡å‹å·²åŠ è½½ï¼Œå¯ä»¥å¼€å§‹æµ‹è¯•');

                                // åŠ è½½æ¨¡å‹åè¿›è¡Œä¸€æ¬¡è¯„ä¼°
                                const evalTarget = config.targetTemp;
                                await this.evaluateTrainingCurve(this.ddpgAgent, config, evalTarget, 600);

                            } catch (innerError) {
                                this.log('âŒ Criticæ¨¡å‹åŠ è½½å¤±è´¥: ' + innerError.message, 'error');
                            }
                        };

                        input2.click();

                    } catch (error) {
                        this.log('âŒ Actoræ¨¡å‹åŠ è½½å¤±è´¥: ' + error.message, 'error');
                        this.updateStatus('âŒ åŠ è½½å¤±è´¥');
                    }
                };

                input.click();
            }
        }
    </script>
</body>

</html>